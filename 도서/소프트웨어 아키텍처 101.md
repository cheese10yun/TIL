> [소프트웨어 아키텍처 101](http://www.yes24.com/Product/Goods/104491433)

# 마이크로커널 아키텍터 스타일

이미 수십 년 전에 만들어진 마이크로커널 아키텍처는 오늘날에도 널리 쓰이고 있습니다. 이 아키텍처 스타일은 단일 모놀리식 배포 단위 패키징해서 다운로드 및 설치가 가능하며, 보통 고객 사이트에서 서드파티 제품으로 설치되는 제품 기반 애플리케이션에 적합하며, 비제품 고객 비지니스 애플리케이션에서도 많이 사용됩니다.

## 토폴로지
![](https://raw.githubusercontent.com/cheese10yun/TIL/master//assets/img-101.png)

마크로커널 아키텍서 스타일은 코어 시스템과 플러그인 컴포넌트 라는 두 가지 아키텍처 요소로 구성된 비교적 단순한 모널리식 입니다. 애플리케이션 로직은 독립적인 플러그인 컴포넌트와 기본 코어 시스템에 골고루 분산되어 확작성, 적응성, 애플리케이션 기능 분리, 커스텀 처리 등을 수행합니다.

> Comment
> 
> 마이크로커널 아키텍처라는 것이 코어 시스템과 컴포넌트가 핵심으로 보인다. 일반적인 마이크로서비스와 마이크로커널과는 상당히 다른 것으로 보여지며 마이크로서비스 아키텍처는 분산 환경에서의 시스템의 유기적인 조화와 그에 따른 안전성에 대한 부분으로 이해하고 있다.

### 코어 시스템
이클립스가 좋은 예입니다. 이클립스 코어 시스템은 파일을 열고, 텍스트를 고치고, 다시 파일을 저장할는 기본적인 텍스트 에디터에 불과합니다. 플러그인을 추가해야 비로소 쓸 만한 제품이 되죠. 그러나 다른 관점에서 바라보면, 코어 시스템은 커스텀 처리가 거의/전혀 필요 없는 애플리케이션을 관통하는 정상 경로 라고 정의할 수 있습니다. 코어 시스템의 순한 복잡도를 없애고 별도의 플러그인 컴포넌트를 장차갛면 확장성, 유지보수성은 물론 시험성도 좋아집니다.

중략..

예를 들어 Payment Processing이 코어 시스템을 나타내는 도메인이라면, 결제 도메인에 특정한 각 결제 수단(신용카드, 페이팔, 선불 카드. 기프트 카드 등)이 플러그인 컴포넌트가 되겠죠. 어떤 경우에도 전체 모놀리스 애플리케이션은 하나의 데이터베이스를 공유하는 것이 보통 입니다.

![](https://raw.githubusercontent.com/cheese10yun/TIL/master//assets/img_101_2.jpg)

코어 시스템 프리젠테이션 레이어는 코어 시스템에 내장하거나 별도의 UI로 구현하고 코어 시스템은 백엔드 서비스를 제공합니다.

![](https://raw.githubusercontent.com/cheese10yun/TIL/master//assets/img_101_3.png)

> Comment
> 
> 플러그인 컴포넌트 라고 하는 것으로 보아. 라이브러리 형태, Jar 형식의 공유를 말하는거 같은데. 개인적이로는 이런 패턴은 극히 싫어 한다. 일단 내부 시스템내에서 멀티 모듈성 컴포넌트 공유는 찬성하지만 코어 시스템이라는 것으로 하고 외부 서비스에게 이런 형식으로 공유하는 것은 반대하며, 내가 의사 결정권이 있는 경우 이런 시스템을 절대 택하지 않을거 같다. 내부 시스템 말고 외부 시스템, 외부 고객사 들에게 전달해주는 패턴으로는 적절해 보인다.

### 플러그인 컴포넌트
코어 시스템은 어떤 플러그인을 사용할 수 있는지, 그 플러그인을 가져오려면 어떻게 해야 하는지 알고 있어야 합니다. 가장 일반적인 구현 방법은 플러그인 레지스트리를 경우하는 것입니다. 이 레지스트리에는 플러그인 명칭, 데이터 계약, 세부 원격 엑세스 프로토컬 등 각 플러그인 모듈에 관한 정보가 있습니다.

> Comment
> 
> 어떤 부분을 말하는건지 잘 이해는 되지 않지만 레지스트리 등록을 하는 넥서스나, 도커 허브 같은 것을 이야기하는 것으로 추청된다.

## 계약
플러그인 컴포넌트와 코어 시스템 간의 계약은 보통 플러그인 컴포넌트의 도메인 단위로 표준화되어 있고, 플러그인 컴포넌트가 수행하는 기능 및 입출력 데이터는 계약에 명시되어 있습니다. 서드파티 회사가 개발한 플러그인 컴포넌트의 계약을 어려분들 마음대로 바꿀 수 없을 떄에는 보통 커스텀 계약을 사용하며, 일반적인 코어 시스템이 각 플로그인별 코드를 필요로 하지 않도록 플러그인 계약과 여러분이 정한 표준 계약 간의 어댑터를 만듭니다.

> Comment
> 
> 코어 시스템과, 그 하위의 플러그인 컴포넌의 간에 서로의 역활과 챔임에 대한 것으로 보인다. 그런데 설명이 이게 적절한지는 모르겠다...

## 실제 용례
이클립스 IDE, PMD, JIRA, Jenkins 등 많은 소프트웨어 개발/릴리스 도구가 마이크로 커널 아키텍처를 사용해서 개밸됐습니다.

> Comment
> JIRA 같은 도구에는 적잡하다고 생각한다. 대략적으로 정리했을 때 외부(고객사) 에게 특정 서비스를 제공(설치형) 하거나, 외부(고객사) 웹페이지에 특정 기능을 제공하는 상담 쳇봇, 결제 모듈 등등 이런 서비스에는 적합한 모듈로 보이지만 실제 일반적인 서비스 업에서는 이런 패턴은 적절해 보이지 않는다.


# 14 이벤트 기반 아키텍트 스타일

이벤트 기반 아키텍트는 확장성이 뛰어난 고성능 애플리케이션 개발에 널리 쓰이는 비동기 분산 아키첵터 스타일입니다. 적응성이 아주 좋아서 소규모 애플리케이션 부터 크고 복잡한 애플리케이션까지 두루 사용할 수 있습니다. 이벤트 기반 아키텍트는 이벤트를 비동기 수신/처리하는 별도의 이벤트 처리 컴포넌트들로 구성되며, 스탠드얼론 아키텍트 스타일로 사용하거나 다른 아키텍트 스타일에 내장할 수도 있습니다.

브로커 토폴로지는 게 가지 기본 아키텍트 컴포넌트, 즉 시작 이벤트, 이벤트 브로커, 이벤트 프로세서, 처리 이벤트로 구성됩니다. 

예를 들어, 어느 시스템 유저가 지난 반년치 주문 이력을 검색한다고 할 때 주ㄴ 이ㄱ 조회는 특정 콘텍스트에서 시스템에 데터를 달라고 전달된, 데터 기반의 확장적인 요청이지, 시템이 반응해야 할 이벤트는 아닙니다. 반면 이벤트 기반 모델은 특정한 상황에 대응하여 그 이벤트에 알맞는 액션을 취합니다. 


## 브로커 토폴로지

브로커 토폴로지는 네 가지 기본 아키텍트 컴포넌트, 즉 시작 이벤트. 이벤트 브로커, 이벤트 프로세서, 처리 이벤트로 구성됩니다. 시작 이벤트는 단순한 이벤트, 복잡한 이벤트든 전체 이벤트 흐름을 개시하는 이벤트를 말합니다. 시작 이벤트는 이벤트 브로커의 이베느 채널로 전송되어 처리됩니다. 이벤트 관리 제어하는 중재자가 브로커 포톨로지에 없으므로 단일 이벤트 프로세서는 이벤트 브로커에서 시작 이벤트를 받자마자 관련된 처리 작업을 마친 뒤 처리 이벤트를 생성하고 시스템의 나머지 부분ㅇ에 자신이 한 일을 비동기로 알립니다.

# 16 오케스트레이션 기반 서비스 지향 아키텍트 스타일


## 택노미
이 아키텍트의 중심 철학은 엔터프이즈 레벨의 재사용입니다.


# 17 마이크로서비스 아키텍트 스타일

마크로소바스는 소프트웨어 프로젝트의 논리적 설계 프로세스를 강조한 도메인 주도 설계 사상의 영향을 많이 받았습니다. 특히 디커플링 스타일을 나타내는 바운디드 컨텍스트 개념은 마이크로서비스에 결정적인 영향을 미쳤습니다.

전통적인 모노리식 아키텍처에서는 수많은 개념을 공유하고 재사용 가능한 클래스를 만들어 데이터베이스에 접속했습니다. 바운디드 컨텍스트 내부에서 코드, 데이터 스키마 같은 내무 요소들이 함께 연결되어 동작하지만, 경계 콘텍스트 외붸 있는 것들은 전혀 커플링되지 않습니다. 이로써 각 콘텍스트는 다른 구성원을 수용하지 않고 자신이 필요한 것들만 정의할 수 있습니다.

그러나 고도의 디커플링이 아키첵트의 목표라면 재사용보다 중복을 우선할 것이빈다. 마이크로서비스의 주요 목표는 바운디드 컨텍스트의 논리적인 개념을 물리적으로 모델링하는 고도의 디커플링입니다.

## 토폴로지

![](https://raw.githubusercontent.com/cheese10yun/TIL/master/assets/101-17-11.jpg)

마이크로서비스는 단일 목적만 가지기 떄문에 오케스트레이션 기반의 서비스 지향 아키첵터와 같은 다른 분산 아키첵터 보다 서비스 규모가 훨씬 작습니다. 실제로 각 서비스에는 데이터베이스 및 기타 종속적인 컴포넌트 등 서비스가 독립적으로 작동되는 데 필요한 모든 것들이 준비되어 있습니다.

> 코멘트
> 
> 오케스트레이션 기반의 서비스 지향 아키첵터에서는 디비는 같은데 서비스 단위로 나누는 것으라고 하긴 하는데 어차피 자신의 책임과 역활에 대해서만 알고 외부에 대한 상세합은 모르는 것이 핵심이기 때문에 크게 다르지 않다고 본다.
> 
> 2, 3 서비스에서는 서로 큐 기반으로 데이터 파이프 라인을 구축하는 것으로 보이는데 좋은 설명인거 같다.

## 분산
마이크로서비스는 분산 아키첵터를 형성합니다. 서비스는 자체 프로세스로 실해되며, 원래 물리적인 컴퓨터를 의미하게씾만 이제는 가상 머신과 컨테이너로 빠르게 진화했습니다.

다수의 애플리케이션을 관리할 때에더 네트워크 대여폭, 메모리, 디스크 공간 등 여러 가지혜택을 운영 측면에서 재사용할 수 있습니다. 그러나 지원해야할 애플리케이 계속 늘어나면 결국 일부 리소스는 공유 인프라의 제약을 받을 수 밖에 없습니다.

클라우드 리소스와 컨테이너 기술을 활용해 도메인 레벨, 운영 레벨 모두 디커플링의 이점을 누릴 수 있게 됐습니다. 

> 코멘트
> 
> 마이크로 서비스는 k8s같은 컨테이너 오케스트레이션 환경에 적합하다고 하는거 같다. 동의하지만 서비스의 크기가 그렇게 크지 않고 k8s 인프라에 대한 구축 노하우 및 운영 노하우가 없다면 그냥 물리 서버에서 동작하는 환경을 구축 해도 무방하다고 생각한다.
> 
> 결국 증요한 것은 역활과 책임의 분리이며, 그 것을 유연하게 연결하는 인터페이스의 조합이라고 생각한다.


## 바운디드 컨텍스트

마이크로서비스의 근본 척할은 바운디드 컨텍스트 개념입니다. 서비스마다 도메인이나 워크플로우를 모델링하는 개념이이지요. 예를 들어 모노리스 사고 방식은 Address 같은 공통 클래스를 다른 애플리케이션 파트의 개발자가 공유하는 것이 당연하지만, 마이크로서비스는 커플링을 가급적 삼가하므로 이 아키첵터 스타일을 구축하는 아키첵트는 커플링보다는 차라리 중복이 낫다고 생각합니다.

> 코멘트
> 
> 그렇게 적절한 예로 보이지 않긴 한다. 바운디드 컨텍스트라는 것은 문맺(서비스의 문맥)에 맞게 해석되고 관리되는 것으로 생각한다.
> 
> 주문이라는 컨텍스트가 있다. 일반적으로 회원이 주문을 하기 때문에 주문자를 member 라고 생각할 수 있지만, 비회원 주문 등등 주문이라는 컨텍스트에서는 orderer(주문자)라고 해석하는 것이 바람직하다.
> 
> 그렇다면 Member 객체를 중복으로 구현하는게 아니라. 본인의 컨텍스트 즉 바운디드 컨텍스트에 맞게 해석 하여 구현하는 것이 더 올바른 해석으로 보인다. 물론 그 개념이 너무 간단해서 중복 코드 처럼 나오는 경우도 있지만 단순히 중복 이라고만 해석하는 건 좋은 해석은 아니라고 생각한다.

### 세분도

아키첵트는 마이크로소비스의 알맞는 세분도를 잘게 위헤 고심하다가 종종 서비스를 너무 잘게 나누는 실수를 저지르곤 합니다.

### 목적
각 마이크로서비스가 기능적으로 매우 응집되어 있고 전체 애플리케이션을 대표하여 하나의 핵심 기능을 제공하는 것이 가장 이상적인 모습입니다.

### 트랜잭션
여러 엔티티가 함께 개입하여 작동되는 트랜잭션을 아키텍트에서 좋은 서비스 경계 후보입니다. 분산 아키텍처에서 트랜잭션은 문제가 될 소지가 있으므로 그런 문제를 방지할 수 있도록 설계하는 것이 바람직합니다.

### 데이터 격리

아키텍트 전체에 데이터를 분삭시킬 수 있을 지 결정해야 합니다. 아니면 데이터베이스 복제나 캐시 기술로 정보를 분산시키든지, 뭔가 구체적인 방인이 필요하다.

> 코멘트
> 
> 사실 해당 마이크로 서비스를 개발하는 개발자들이 그 데이터 격리 대해서 고민하기 때문에 이 부분은 크게 공감이 가질 않는다.
> 책 초반에서 나왔던 아키텍트가 모든 것을 설계하는 사상이 여기에서도 나오는거 같은데 마이크로 서비스 아키텍트로 가면 결국 그 서비스에 대한 오너십은 해당 개발자가 되는것이고 그 개발자가 아키텍트가 되는 그림이다. 

## API 레이어

모든 비지니스 로직은 바운디드 컨텍스트 내부에서 일어나야 합니다.

## 운영 재사용

마이크로서비스가 커플링보다 복제를 선호한다고 했습니다. 그러면 모니터링, 로깅, 회로 차단기 등의 운영 관심사와 같이 실제로 커플링이 더 유리한 아키텍트 부분은 어떻게 처리해야할까요? 

마이크로서비스 아키텍트는 이 두 가지 관심사를 분리하고자 합니다.

![](https://raw.githubusercontent.com/cheese10yun/TIL/master/assets/101-17-10.jpg)

각 서비스마다 별도의 컴포넌트에 두고, 해당 팀이나 공유 인프라팀이 소유할 수 있도록 합니다. 사이드카 컴포넌트는 팀이 서로 커플링되면 더 유리한 모든 운영 관심사를 도 맡아 처리합니다. 따라서 모니터링 도구를 업그레이드할 때가 되면 공유 인프라팀이 사이드카를 업데이트 하는 방식으로 각 마이크로서비스는 신기능을 받아 사용할 수 있습니다.

![](https://raw.githubusercontent.com/cheese10yun/TIL/master/assets/101-17-09.jpg)

> 코멘트
> 
> 이것도 동의하기가 힘들다. 로깅, 모니터링(APM)등 인프라 도구는 애플리케이션 코드에 비침투적인 방향으로 발전 해왔고, 지금도 그렇다.
> 애플리케이션 코드 레벨에 침투하는 것은 올바른 방향은 아니라고 생각하며 만약 모니터링 도구가 변경되면서 시스템이 변경되는 경우에도 그 여파가 적게 설계하는 것이 일반적이다.
> 
> 예를 들어 인프라 레벨에서 로그 수집 도구를 변경한다고 하더라도 기존에 서로 약속된 경로, 패턴 등에 파일 기반으로 내려주는 방식이 였다면 크게 변경될 여지가 없다.
> 
> 무튼 하고 싶은 말의 핵심은 애플리케이션 코드에 침투하는 모니터링 쪽은 올바르지 않다고 생각하며, 그런 부분이 없을 수는 부분도 있다 이런 부분은 위에서 이야기 했듯이 어느 플랫폼을 쓰더라도 그 영향이 적은 일반적인 시스템을 이용해야 한다.


## 프론트엔드

마이크로서빗 아키텍처의 유저 인터페이스는 보통 두 가지 스타일로 나타납니다.

![](https://raw.githubusercontent.com/cheese10yun/TIL/master/assets/101-17-08.jpg)

요청을 처리하기 위한 단일 유저 인터페이스가 API 레이어를 통해 호출하는 모노식 프론트엔드 입니다.

![](https://raw.githubusercontent.com/cheese10yun/TIL/master/assets/101-17-07.jpg)

백엔드 서비스로 활용하여 유저 인터페이스를 동기적인 수준으로 세분화하고 격리합니다.

> 코멘트
> 
> 이런 부분에 필요성을 느껴본적은 없어 딱히 코멘트할게 없습니다. 
> 모놀로식 유저 인터페이스에서 여러 서비스를 호출하는 서비스 구현도 사실 어려운 부분이 있는데 마이크로 프론트엔드라?...음


## 통신
동기로 할지, 비동기로 할지 통신 방식을 결정해야합니다.

프로토콜 인지
서비스는 다른 서비스를 호출할 때 어떤 프로토콜을 사용할지 알아야 합니다. 아키텍트는 여러 서비스가 상대방을 호출하는 방식을 표준화 합니다.

이종
마이크로서비스는 분산 아키텍처라서 각 서비스마다 구현 기술 스택이 상이할 수 있습니다. 이종이란, 서비스 마다 사용되는 플랫폼이 저마다 다른 폴리그랏 환경을 완벽하게 지원한다는 뜻입니다.

상호 운용성
여러 서비스가 서로 호출한다는 뜻입니다. 마이크로 서비스에서 트랜잭션 메서드 호출을 권장하지 않지만, 어쩃거나 서비스는 네트워크를 통해 다른 서비스를 호출하여 정보를 주고 받으면서 협력해야 합니다.

### 코레오그래피와 오케스트레이션

코레오그래피는 브로커 이벤트 기반의 아키텍처와 통신 스타일이 동일합니다. 즉 이 아키첵터는 중앙 중재자가 따로 없고 바운디드 컨텍스트 철학에 출실합니다.

![](https://raw.githubusercontent.com/cheese10yun/TIL/master/assets/101-17-09.jpg)

필요한 정보가 외부 서비스에 있다면 그 서비스를 호출하여 필요한 정보를 가져옵니다.


![](https://raw.githubusercontent.com/cheese10yun/TIL/master/assets/101-17-05.jpg)

해당 일을 담당하는 서비스를 만들어 중재자가 다른 서비스를 호출하여 데이터를 생성합니다. 어느 쪽이든 완벽한 정답은 없고 각각 일당일단이 있습니다.

> 코멘트
> 
> 오케스트레이션 방식은 상다히 많은 분석과 통찰이 이루어진 이후에 만들어져야 한다고 생각한다. 현재는 중간 서비스 -> 원천 서비스 2 depth를 가지지만 depth가 늘어 날수 있고, 또 다른 서비스를 호출 해야하는 경우가 생길수 있습니다. 아주 명확하지 않다면 코레오그래피 방식으로 개발하고 필요한 경우가 생기면 오케스트레이션으로 넘어가는 것이 좋다고 생각한다.



![](https://raw.githubusercontent.com/cheese10yun/TIL/master/assets/101-17-04.jpg)

![](https://raw.githubusercontent.com/cheese10yun/TIL/master/assets/101-17-03.jpg)


### 트랜잭션과 사가

분산 애플리케이션에서는 데이터베이스 역시 동일한 수준의 디커플링이 필요하므로 모노식 애플리케이션에서 별 문제가 아니였던 원자성 문제가 발생합니다.

![](https://raw.githubusercontent.com/cheese10yun/TIL/master/assets/101-17-02.jpg)

트랜잭션을 조정 합니다. 중재자는 트랜잭션을 구성하는 파트를 하나씩 호출하여 성공/실패 여부를 기록하고 그 결과에 따라 흐름을 조정합니다. 어느 한 파트라도 실패하면 중재자는 전체 트랜잭션 파트가 모두 성공하지 못하게 해야 합니다.


![](https://raw.githubusercontent.com/cheese10yun/TIL/master/assets/101-17-01.jpg)


중재자는 지금까지 성공한 모든 트랜잭션 파트에게 과거에 처리했던 내용을 언두라는 요청을 보냅니다. 이런 종류의 트랜잭션을 조정을 보장 트랜잭션 프레잌워크라고 합니다.

하지만 여기에 비동기 요청이 끼어들고, 특히 보류된 트랜잭션 상태에 따라 새로운 요청이 등장하면서 설계가 무척복잡해 집니다. 또 네트워크 레벨에서도 조정 트래픽이 꽤 많이 발생합니다.

트랜잭션 작업마다 두/언두 로직 개발을 하는 식으로 보상 트랜잭션 프레임워크를 구현할 수 있습니다.

> 코멘트
> 
> 매번 보상 트랜잭션까지 API를 개발해야 하는 것이 작업양에 많은 영향을 미치기 떄문에 좋은 대안이라고는 생각들지 않지만. 이 방법외에는 딱히 적절한 방법이 없긴 합니다.
> 
> 또 read timeout, connection timeout이 발생하는 경우 요청한 쪽에서는 실패로 간주하고 보상 트랜잭션을 호출 할 수 밖에 없고, 그 요청이 실제로는 성공 했을 경우도 염두해야 하는 등등에 대한 코드도 필요합니다.
> 
> 개인적으로는 API마다 원자성을 보장하는 방법 보다는 주기적으로 두 시스템의 데이터가 같은지 확인하는 방법이 더 효율적이고 현실적인 방법이라고 생각합니다.



