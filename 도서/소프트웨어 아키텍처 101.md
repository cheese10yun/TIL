> [소프트웨어 아키텍처 101](http://www.yes24.com/Product/Goods/104491433)

# 마이크로커널 아키텍터 스타일

이미 수십 년 전에 만들어진 마이크로커널 아키텍처는 오늘날에도 널리 쓰이고 있습니다. 이 아키텍처 스타일은 단일 모놀리식 배포 단위 패키징해서 다운로드 및 설치가 가능하며, 보통 고객 사이트에서 서드파티 제품으로 설치되는 제품 기반 애플리케이션에 적합하며, 비제품 고객 비지니스 애플리케이션에서도 많이 사용됩니다.

## 토폴로지
![](https://raw.githubusercontent.com/cheese10yun/TIL/master//assets/img-101.png)

마크로커널 아키텍서 스타일은 코어 시스템과 플러그인 컴포넌트 라는 두 가지 아키텍처 요소로 구성된 비교적 단순한 모널리식 입니다. 애플리케이션 로직은 독립적인 플러그인 컴포넌트와 기본 코어 시스템에 골고루 분산되어 확작성, 적응성, 애플리케이션 기능 분리, 커스텀 처리 등을 수행합니다.

> Comment
> 
> 마이크로커널 아키텍처라는 것이 코어 시스템과 컴포넌트가 핵심으로 보인다. 일반적인 마이크로서비스와 마이크로커널과는 상당히 다른 것으로 보여지며 마이크로서비스 아키텍처는 분산 환경에서의 시스템의 유기적인 조화와 그에 따른 안전성에 대한 부분으로 이해하고 있다.

### 코어 시스템
이클립스가 좋은 예입니다. 이클립스 코어 시스템은 파일을 열고, 텍스트를 고치고, 다시 파일을 저장할는 기본적인 텍스트 에디터에 불과합니다. 플러그인을 추가해야 비로소 쓸 만한 제품이 되죠. 그러나 다른 관점에서 바라보면, 코어 시스템은 커스텀 처리가 거의/전혀 필요 없는 애플리케이션을 관통하는 정상 경로 라고 정의할 수 있습니다. 코어 시스템의 순한 복잡도를 없애고 별도의 플러그인 컴포넌트를 장차갛면 확장성, 유지보수성은 물론 시험성도 좋아집니다.

중략..

예를 들어 Payment Processing이 코어 시스템을 나타내는 도메인이라면, 결제 도메인에 특정한 각 결제 수단(신용카드, 페이팔, 선불 카드. 기프트 카드 등)이 플러그인 컴포넌트가 되겠죠. 어떤 경우에도 전체 모놀리스 애플리케이션은 하나의 데이터베이스를 공유하는 것이 보통 입니다.

![](https://raw.githubusercontent.com/cheese10yun/TIL/master//assets/img_101_2.jpg)

코어 시스템 프리젠테이션 레이어는 코어 시스템에 내장하거나 별도의 UI로 구현하고 코어 시스템은 백엔드 서비스를 제공합니다.

![](https://raw.githubusercontent.com/cheese10yun/TIL/master//assets/img_101_3.png)

> Comment
> 
> 플러그인 컴포넌트 라고 하는 것으로 보아. 라이브러리 형태, Jar 형식의 공유를 말하는거 같은데. 개인적이로는 이런 패턴은 극히 싫어 한다. 일단 내부 시스템내에서 멀티 모듈성 컴포넌트 공유는 찬성하지만 코어 시스템이라는 것으로 하고 외부 서비스에게 이런 형식으로 공유하는 것은 반대하며, 내가 의사 결정권이 있는 경우 이런 시스템을 절대 택하지 않을거 같다. 내부 시스템 말고 외부 시스템, 외부 고객사 들에게 전달해주는 패턴으로는 적절해 보인다.

### 플러그인 컴포넌트
코어 시스템은 어떤 플러그인을 사용할 수 있는지, 그 플러그인을 가져오려면 어떻게 해야 하는지 알고 있어야 합니다. 가장 일반적인 구현 방법은 플러그인 레지스트리를 경우하는 것입니다. 이 레지스트리에는 플러그인 명칭, 데이터 계약, 세부 원격 엑세스 프로토컬 등 각 플러그인 모듈에 관한 정보가 있습니다.

> Comment
> 
> 어떤 부분을 말하는건지 잘 이해는 되지 않지만 레지스트리 등록을 하는 넥서스나, 도커 허브 같은 것을 이야기하는 것으로 추청된다.

## 계약
플러그인 컴포넌트와 코어 시스템 간의 계약은 보통 플러그인 컴포넌트의 도메인 단위로 표준화되어 있고, 플러그인 컴포넌트가 수행하는 기능 및 입출력 데이터는 계약에 명시되어 있습니다. 서드파티 회사가 개발한 플러그인 컴포넌트의 계약을 어려분들 마음대로 바꿀 수 없을 떄에는 보통 커스텀 계약을 사용하며, 일반적인 코어 시스템이 각 플로그인별 코드를 필요로 하지 않도록 플러그인 계약과 여러분이 정한 표준 계약 간의 어댑터를 만듭니다.

> Comment
> 
> 코어 시스템과, 그 하위의 플러그인 컴포넌의 간에 서로의 역활과 챔임에 대한 것으로 보인다. 그런데 설명이 이게 적절한지는 모르겠다...

## 실제 용례
이클립스 IDE, PMD, JIRA, Jenkins 등 많은 소프트웨어 개발/릴리스 도구가 마이크로 커널 아키텍처를 사용해서 개밸됐습니다.

> Comment
> JIRA 같은 도구에는 적잡하다고 생각한다. 대략적으로 정리했을 때 외부(고객사) 에게 특정 서비스를 제공(설치형) 하거나, 외부(고객사) 웹페이지에 특정 기능을 제공하는 상담 쳇봇, 결제 모듈 등등 이런 서비스에는 적합한 모듈로 보이지만 실제 일반적인 서비스 업에서는 이런 패턴은 적절해 보이지 않는다.


# 14 이벤트 기반 아키첵처 스타일

이벤트 기반 아키첵처는 확장성이 뛰어난 고성능 애플리케이션 개발에 널리 쓰이는 비동기 분산 아키첵터 스타일입니다. 적응성이 아주 좋아서 소규모 애플리케이션 부터 크고 복잡한 애플리케이션까지 두루 사용할 수 있습니다. 이벤트 기반 아키첵처는 이벤트를 비동기 수신/처리하는 별도의 이벤트 처리 컴포넌트들로 구성되며, 스탠드얼론 아키첵처 스타일로 사용하거나 다른 아키첵처 스타일에 내장할 수도 있습니다.

브로커 토폴로지는 게 가지 기본 아키첵처 컴포넌트, 즉 시작 이벤트, 이벤트 브로커, 이벤트 프로세서, 처리 이벤트로 구성됩니다. 

예를 들어, 어느 시스템 유저가 지난 반년치 주문 이력을 검색한다고 할 때 주ㄴ 이ㄱ 조회는 특정 콘텍스트에서 시스템에 데터를 달라고 전달된, 데터 기반의 확장적인 요청이지, 시템이 반응해야 할 이벤트는 아닙니다. 반면 이벤트 기반 모델은 특정한 상황에 대응하여 그 이벤트에 알맞는 액션을 취합니다. 


## 브로커 토폴로지

브로커 토폴로지는 네 가지 기본 아키첵처 컴포넌트, 즉 시작 이벤트. 이벤트 브로커, 이벤트 프로세서, 처리 이벤트로 구성됩니다. 시작 이벤트는 단순한 이벤트, 복잡한 이벤트든 전체 이벤트 흐름을 개시하는 이벤트를 말합니다. 시작 이벤트는 이벤트 브로커의 이베느 채널로 전송되어 처리됩니다. 이벤트 관리 제어하는 중재자가 브로커 포톨로지에 없으므로 단일 이벤트 프로세서는 이벤트 브로커에서 시작 이벤트를 받자마자 관련된 처리 작업을 마친 뒤 처리 이벤트를 생성하고 시스템의 나머지 부분ㅇ에 자신이 한 일을 비동기로 알립니다.

