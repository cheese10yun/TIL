> [학교에서 알려주지 않는 17가지 실무 개발 기술](http://www.yes24.com/Product/Goods/89906094)를 보고 정리한 내용입니다.

# 문자열 인코딩

## 문자열 인코딩이란
**문자열 인코딩 이란 2진법을 사용하는 컴퓨터가 인간의 언어를 일정한 큐칙에 따라 2진수로 뱐환하는 방식입니디.** 컴퓨터는 `안녕하세여`와 같은 문자을 그래도 읽거나 처리할 수 없기 때문입니다.

**그래서 컴퓨터는 사람들이 만든 2진수와 문자를 일대일로 대응하는 규칙을 통해 2진수로 문자를 처리합니다.** `EUC-KR`, `UTF-8`, `UTF-16`, `UTF-32` 이러한 규칙에 포함됩니다. 문자열 인코딩 규칙은 종류에따라 변호나 방식이 조금씩 다르지만 원리는 간단합니다.

아스키 코드를 예를 들면 2진수 `01000001`을 10진수로 읽으면 `65`가 되지만, 아스키 코드로 읽으면 문자 `A`가됩니다. 

여러 국가에서 컴퓨터를 사요아기 위해 국가별로 사용하는 언어를 표현하고자 독자적인 규칙을 만들기 시작했습니다. 모든 언어를 같은 규칙으로 표현할 수 있는 유니코드 방식이 등장하기 전까지 말입니다.

개발자는 서로 호환되지 않은 유니코드 문자열 인코딩 방식 `UTF-8`, `UTF-16`, `UTF-32` 중 하나를 책해야 합니다. 심지어 한국에서는 유니코드가 등장하기 전에 만든 독자적인 인코딩 방식 `EUC-KR`을 쓰는 오래된 시스템도 아직 남아 있습니다.

개발자들은 문자열 인코딩 외 **문자 집합** 이라는 용어도 함께 사용합니다. 엄격하게 구분하면 문자 집합은 사용할 수 있는 문자들의 집합을 말합니다. 유니코드, ISO-8859, ASCII 등이 이에 해당합니다.

반면 문자열 인코딩은 문자를 코드로 표현하는 방식을 일컷습니다. 예를 들어 유니코드라는 문자 집합을 표현하는 문자열 인코딩은 `UTF-8`, `UTF-16`, `UTF-32`등이 있습니다.

## 아스키 코드
아스키 코드는 처음으로 표휸을 정립한 문자열 인코딩 방식으로 아직까지 많이 사용됩니다. 사용할 수 있는 문자의 종류에는 대문자, 소문자, 아리바아 숫자, 공백 및 특수문자들이 있으며 문자를 표현할 때는 0 ~ 127, 총 128개의 숫자를 사용합니다.

![](https://ww.namu.la/s/05acaba21abdca4ab79fdc7a1c604e2535b074bbe37a51181d89120499081e0d19000a106a7c96c99bebf82bc785f0e8ff45a98a32493cef61ba8722acef83475d80e50d978d53ad6e2bf2e9f3a05f0c69f20a8ec8aeec85f7c62c2b4816a564)

**컴퓨터는 2진수 데이터를 한 가지 형태로만 인식할 수 있기 때문에 숫자와 문자를 동시에 인식할 수 없습니다.** 이러한 문제를 해결하기 위해 숫자를 나타내는 문자열을 만들었습니다.

## EUC-KR
EUC-KR은 한국 산업 표준으로 지정되어 한국 문자 집합으로 문자 하나를 표현하기 위해 2바이트를 사용합니다. 단 아스키 코드 문자를 표현할 때는 1바이트를 사용하기 대문에 아스키 코드와 호환됩니다.

**EUC-KR은 모든 글자가 완성된 형태로만 존재하는 완성형 코드입니다.** 따라서 한글 처럼 초성, 중성, 조성을 조합해 문자를 만들수 없기 때문에 EUC-KR로 표현할 수없는 한글이 일부 존재합니다. 물론 일반적으로 사용하는 문자는 아니기긴 합니다.

```
'Hello' 문자열 길이 : 5
'Hello' 전체 문자를 표현하는 데 사용한 바이트 수 : 5 바이트
'Hello' 16진수 값: 0x48 0x65 0x6c 0x6c 0x6f
'Hello' 10진수 값: 72 101 108 108 111

'안녕하세요' 문자열 길이: 5
'안녕하세요' 전체 문자를 표현하는 데 사용한 바이트 수 : 10 바이트
'안녕하세요' 16진수 값: 0xbe 0xc8 0xb3 0xe7 0xc7 0xcf 0xbc 0xbc 0xbf 0xe4
'안녕하세요' 10진수 값: 190 200 179 231 199 207 188 181 288
```
`안녕하세요`를 출력하기 위해서는 10바이트를 사용했습니다. `EUC-KR`로 아스키 코드 영역에 있는 글자를 표현할 때는 1바이트를 사용하지만, 한글 문자 표현할 때는 2바이트를 사용하기 때문입니다. 이처럼 **문자열 인코딩에서는 실제 문자열 길이가 버퍼길이와 다른 경우가 많습니다. 실제 문자열 길이는 사람 눈에 보이는 문자열에 해당하고, 버퍼 길이는 컴퓨터가 문자를 표현하는 데 사용하는 바이트 수를 의미합니다.** 그래서 실제 문자열 길이와 컴퓨터가 할당하는 버퍼 크기는 항상 다를 수 있다는 점을 꼭 기억하시길 바랍니다.

## 유니코드 `UTF-8`, `UTF-16`, `UTF-32`
국가별로 독자적인 문자열 인코등을 사용하는 문제를 해결하기 위해 국제 표준 기구에서 동일한 규칙으로 모든 언어를 표현할 수 있는 유니코드 문자열집합을 만들었습니다.

### `UTF-8`
`UTF-8`은 8비트(바이트)로 인코딩을 표현하는 것을 의미합니다. `UTF-8`은 아스키코드와 완벽하게 호환되며, 표현하려는 문자에 따라 최소 1바이트 최대 6바이트까지 사용합니다.


바이트 수 | 바이트 1 | 바이트 2 | 바이트 3 | 바이트 4 | 바이트 5 | 바이트 6
-----|------|------|------|------|------|-----
1 | 0xxxxxxx | - | - | - | - | -
2 | 110xxxxx | 10xxxxxx | - | - | - | -
3 | 1110xxxx | 10xxxxxx | 10xxxxxx | - | - | -
4 | 11110xxx | 10xxxxxx | 10xxxxxx | 10xxxxxx | - | -
5 | 111110xx | 10xxxxxx | 10xxxxxx | 10xxxxxx | 10xxxxxx | -
6 | 1111110x | 10xxxxxx | 10xxxxxx | 10xxxxxx | 10xxxxxx | 10xxxxxx

`바이트 수`행의 값은 문자를 표현하는 데 사용하는 총 바이트를 뜻합니다. `바이트 1` ~ `바이트 6`까지 있는 1과 9은 고정된 비트 값이며, 사용하는 비트수에 따라 달라집니다. `x` 문자는 유니코드를 조장하는 데 사요할 비트 영역입니다.

첫 번째 줄(바이트문자 1)은 첫 번째 비트 값이 0이므로 0을 제외한 나머지 비트 7개로 문자를 표현합니다 **0 ~ 127까지 수로 문자를 표현하는 아스키 코드와 같은 규칙을 사용하므로 UTF-8은 아스키 코드와 완벽히 호환됩니다.**

두 번째 줄 (바이트 문자 2)은 비트 값이 `110`으로 시작합니다. 이 경우에는 2바이트로 `UTF-8` 문자를 읽어야 합니다. 첫 번째 바이트의 `1110xxxx`에서 `110`을 제외한 비트 5개, 두 번째 바이트 `10xxxxxx`에서 `10`을 제외한 비트 6개를 조합하면 총 11개의 비트로 `UTF-8` 문자를 만들 수 있습니다.

**보통 일반적인 문자는 3바이트 이내로 처리되며, 4바이트 영역에서 이모지같은 문자가 있습니다.** 고대 문자 같은 것을 사용하지 않은 한 5바이트 이상을 쓰는 경우가 거의 없습니다.

#### `UTF-8` 문자열 출력

```
'Hello' 문자열 길이 : 5
'Hello' 전체 문자를 표현하는 데 사용한 바이트 수 : 5 바이트
'Hello' 16진수 값: 0x48 0x65 0x6c 0x6c 0x6f
'Hello' 10진수 값: 72 101 108 108 111

'안녕하세요' 문자열 길이: 5
'안녕하세요' 전체 문자를 표현하는 데 사용한 바이트 수 : 15 바이트
'안녕하세요' 16진수 값: 0xec 0x95 0x 88 0xeb 0x85 0x 95 0xed 0x95 0x98 0xec 0x84 0x b8 0xec 0x9a 0x94
'안녕하세요' 10진수 값: 236 149 136 235 133 149 237 149 152 236 132 185 236 154 148
```

##### `UTF-8` 문자열 출력: `Hello`
`H`문자가 16진수 `0x48`로 출력됐습니다. `UTF-8`은 아스키코드와 호환되기 때문에 출력되는 값 또한 아스키 코드와 같습니다.

##### `UTF-8` 문자열 출력: `안녕하세요`
한글 5글자를 표현하는 데 15바이트를 사용했습니다. 글자당 3바이트를 사요한 셈입니다. 먼저 `안`을 구성하는 16진수 값은 `0xec`, `0x95`, `0x88`을 각각 2진수료 표현 하면 다음과 같습니다.

16진수 | 2진수
-----|----
0xec | `1110` 1100
0x95 | `10`01 0101
0x88 | `10`00 1000

16진수 값을 차례대로 나열하면 다음과 같습니다

`11101100 10010101 10001000`

조회한 값의 첫 번째 바이트(`1110`1100)는 `1110`으로 시작합니다. 첫 번째 바이트가 (바이트1)가 `1110`으로 시작할 때는 3바이트 크키가 3개의 글자가 되는 것을 알 수 있습니다.

바이트 수 | 바이트 1 | 바이트 2 | 바이트 3 | 바이트 4 | 바이트 5 | 바이트 6
-----|------|------|------|------|------|-----
3 | 1110xxxx | 10xxxxxx | 10xxxxxx | - | - | -

두 번째, 세 번째가 바이트에 있는 비트값 10은 `UTF-8`형식을 구성하는 욛도로만 사용되므로 실제 값을 읽을 때는 사용되지 않습니다.

그래서 첫 번째 바이트 (1110`1110`)에서 `1110`을 제외한 비트값 `1110` 두 번째 바이트(10`010101`)에서 10을 제외한 비트 값 `010101`, 세 번째 바이트(10`001000`)에서 10을 제외한 비트값 (`0010000`)을 읽어서 다시 한번 조합하면 다음과 같은 값을 만들 수 있습니다.

`1100010101001000`

[utf8 to binary](https://onlineutf8tools.com/convert-utf8-to-binary)에서 확인 가능


### `UTF-16`
**`UTF-16` 16비트(바이트)로 인코딩하는 것을 의미합니다.** `UTF-16`은 2바이트 또는 4바이트만 사용하기 때문에 아스키 코드와 호환되지 않습니다. 유니코에는 문자 종류에 따라 기본 다국어 평면, 보충 다국어 평면, 상현 문자 보충 평면, 특수 목적 보충 평면 등 평면 3개가 있고, 바이트수는 표현하려는 문자가 어떤 평면에 속하는지에 따라 결정돱니다. 정리 하면, **`UTF-16`은 일반 글자는 2바이트, 특별한 글자는 4바이트를 사용해 인코딩 합니다.**

### 정리
* `UTF-8` 
  * 오늘날 가장 많이 사용하는 문자열 인코딩이며, 최소 1바이트 쵀대 6 바이트를 사용합니다. 대부분 4바이트 내로 처리합니다.
  * 아스키코드와 호환 가능합니다.
  * 윈도우, 자바 암베디를 제외한 거의 모든 환경에서 문자열 처리 표준으로 봐도 좋습니다.
  * JSON은 `UTF-8` 인코딩만 사용하며, 다른 문자열 인코딩은 표준에서 지원하지 않습니다.
* `UTF-16`
  * 자바와 윈도우는 유니코드를 사용하기 전부터 고정된 2바이트 길이의 문자 집합을 사용했습니다. 그래서 `UTF-16`은 멀티 바이트라고도 합니다. 두 환경에서 호환성 외에 `UTF-16`을 사용할 별다른 이유는 없습니다
  * 2바이트 또는 4바이트 길의 문자열을 사용하며, 아스키 코드와 호환되지 않습니다.
  * `UTF-16` 기반 환경에서는 `UTF-8`을 사용할 때는 사용 영역을 명확히 구분하는게 좋습니다. 예를 들어 자바 기반 웹 서비스는 기본적으로 `UTF-16`을 사용하되, 외부(데이터베이스와 브라우저 간) 통신 시 `UTF-8`로 변환하여 사용하는게 좋습니다.
* `EUC-KR`
  * 한국에서 독자적으로 사용하는 문자열 인코딩으로 고정된 2바이트를 사용합니다
  * 가능하다면 `UTF-8`로 바꾸는게 좋지만 현실적으로 어려운 경우가 많습니다.
* MySQL의 `UTF-8` 타입에 `utf8`, `utf8mb4`가 있습니다. `utf8`은 3바이트 까지 정상적으로 처리하나, 4바이트 영역 문자는 처리하지 못합니다. 따라서 `UTF-8`과 완벽히 호환되는 문자 집합을 쓰고 싶다면 `utf8mb4`을 써야합니다.

# 날짜와 시간
타임 스탬프는 컴퓨터가 시간을 표현하기 위해 사용하는 값입니다. 타임스템프 값은 1970년 1월 1일 0시 0분 0초 부터 1초 단위로 증가 합니다. 1초 단위로 표기한다고 해서 1초 미만의 시간을 측정할 수 없는 건 아닙니다.

컴퓨터가 타임스탬프로 표햔할 수 있는 시간은 두 종류가 있습니다. 하나는 **단조** 시간으로 컴퓨터가 직접 계산하는 시간입니다. 다른 하나는 우리가 사는 세계의 **실제 시간**입니다. 

## 단조
**단조은 운영체자 또는 CPU와 같은 하드웨어에서 직접 계산하는 시간입니다.** 실제 세계 시간과는 다르지만, **운영체자가 시작한 이후 시점부터 바뀌지 않은 특징이 있습니다. 사용자가 직접 값을 변경할 수도 없습니다.** 그러나 시스템 재부팅 이후에는 값이 초기화되므로 재부팅 전보다 현저히 낮은 값으로 바뀌게 됩니다.

**외부 요인에 의해 바꾸지 않은 단조 시간의 특징을 이용하면 불변성을 보장하는 시간 값이 필요할 때 유용하게 사용할 수 있습니다.** 예를 들어 어떤 작업을 10초 또는 1분 마다 수행해야할 때, 단조 시간 값을 가져와 비교하면 항상 동일한 주기로 작업을 실행할 수 있습니다.

## 실제 시간
실제 시간도 컴퓨터가 직접 계산하지만 주기적으로 시간 서버로부터 값을 가져와 동기화하기 때문에 언제든지 시간이 바뀔 수 있습니다. 이러한 이유로 실제 시간은 단조 시간처럼 시간차이를 구하거나 일정한 간격을 측정하기 위해서 사용할 수 없습니다.

그러나 실제 시간 값은 실제 세계의 시간과 항상 일치하여 단조 시간이 할 수 없는 일을 할 수 있습니다. 예를 들어 한 달이 넘는 주기로 스행하는 작업(매달 1일), 특정 날짜에 반드시 실행해야 하는 작업 등의 기준 시간으로써 사용합니다.

**한 달은 30일과 31일 있고 윤년도 염두해두고 계산해야합니다. 따라서 한 달 이상 주기를 두고 실행하는 작업은 실제 시간을 기준으로하는게 좋습니다.**

## 타임존
실제 시간을 사요할 때는 타임존 설정을 꼭 확인 해야합니다. 나라마다 사용하는 표준 시간이 다르기 때문입니다.

### 타임존 설정을 유의해야 하는 이유
타임 존은 운영체제 또는 모바일 기기 설정에 의해 언제든지 바뀔수 있으며, 브라우저와 같은 요청 클라이언트의 설정이나 지역에 따라 타임 존이 바뀌기도 합니다.



