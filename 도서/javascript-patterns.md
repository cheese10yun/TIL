<p align="center">
  <img src="http://image.kyobobook.co.kr/images/book/xlarge/157/x9788966260157.jpg">
</p>

## 목차

<!-- TOC -->

- [목차](#목차)
- [1장](#1장)
- [2장 기초](#2장-기초)
    - [2.1 유지보수 가능한 코드 작성](#21-유지보수-가능한-코드-작성)
        - [요지보수 가능한 코드란 다음과 같은 특징을 지닌다.](#요지보수-가능한-코드란-다음과-같은-특징을-지닌다)
    - [2.2 전역 변수 최소화](#22-전역-변수-최소화)
    - [전역 변수의 문제점](#전역-변수의-문제점)
        - [다음과 같은 경우](#다음과-같은-경우)
        - [변수를 선언 할 경우 항상 var를 사용하기](#변수를-선언-할-경우-항상-var를-사용하기)
        - [예제 코드 안티패턴](#예제-코드-안티패턴)
        - [에제코드 바림직한 패턴](#에제코드-바림직한-패턴)
        - [var 선언을 빼먹었을 때의 부작용](#var-선언을-빼먹었을-때의-부작용)
        - [단일 var 패턴](#단일-var-패턴)
        - [단일 var 패턴 예제](#단일-var-패턴-예제)
        - [호이스팅 : 분산된 var 선언의 문제점](#호이스팅--분산된-var-선언의-문제점)
        - [예제코드](#예제코드)
        - [위의 예제코드는 아래와 동일하게 동작한다.](#위의-예제코드는-아래와-동일하게-동작한다)
    - [2.3 for 루프](#23-for-루프)
    - [일반적인 for 루프 패턴 예제](#일반적인-for-루프-패턴-예제)
    - [2.4 for-in 루프](#24-for-in-루프)
    - [2.6 switch 패턴](#26-switch-패턴)
    - [2.7 암묵적 타입캐스팅 피하기](#27-암묵적-타입캐스팅-피하기)
    - [2.8 코딩 규칙](#28-코딩-규칙)
    - [들여쓰기](#들여쓰기)
    - [생성자를 대문자로 시작하기](#생성자를-대문자로-시작하기)
    - [단어 구분](#단어-구분)
        - [함수경우](#함수경우)
        - [변수](#변수)
    - [API 문서작성](#api-문서작성)
- [3장 리터럴과 생성자](#3장-리터럴과-생성자)
    - [3.1 객체 리터럴](#31-객체-리터럴)
    - [객체 리터럴 문법](#객체-리터럴-문법)
    - [생성자 함수로 객체 생성하기](#생성자-함수로-객체-생성하기)
    - [객체 생성자의 함정](#객체-생성자의-함정)
    - [3.2 사용자 정의 생성자 함수](#32-사용자-정의-생성자-함수)
    - [다음은 `Person` 생성자 함수를 정의한 예시이다.](#다음은-person-생성자-함수를-정의한-예시이다)
    - [3.3 new를 강제하는 패턴](#33-new를-강제하는-패턴)
    - [예제](#예제)
    - [명명 규칙](#명명-규칙)
    - [that 사용](#that-사용)
    - [3.4 배열 리터럴](#34-배열-리터럴)
    - [배열 리터럴 문법](#배열-리터럴-문법)
    - [배열 생성자의 특이성](#배열-생성자의-특이성)
    - [3.5 에러 객체](#35-에러-객체)
    - [요약](#요약)
- [4장 함수](#4장-함수)
    - [4.1 배경지식](#41-배경지식)
        - [함수는 다음과 같은 특징을 가지는 객체다.](#함수는-다음과-같은-특징을-가지는-객체다)
        - [함수도 객체이다](#함수도-객체이다)
        - [용어 정리](#용어-정리)
        - [기명함수 표현식 (named function expression)](#기명함수-표현식-named-function-expression)
        - [무명함수 표현식 (unnamed function expression)](#무명함수-표현식-unnamed-function-expression)
        - [차이점](#차이점)
        - [함수 선언문](#함수-선언문)
        - [선언문 vs 표현식 : 이름과 호이스팅](#선언문-vs-표현식--이름과-호이스팅)
        - [험수의 name 프로퍼티](#험수의-name-프로퍼티)
        - [함수 호이스팅](#함수-호이스팅)
        - [마무리](#마무리)
    - [4.2 콜백 패턴](#42-콜백-패턴)
        - [라이브러리에서의 콜백](#라이브러리에서의-콜백)
    - [4.3](#43)
    - [4.4 자기 자신을 정의하는 함수](#44-자기-자신을-정의하는-함수)
    - [4.5 즉시 실행함수](#45-즉시-실행함수)
    - [즉시 실행 함수 매개변수](#즉시-실행-함수-매개변수)
    - [즉시 실행 함수의 반환 값](#즉시-실행-함수의-반환-값)
    - [장점과 사용 방법](#장점과-사용-방법)
    - [4.6 즉시 객체 초기화](#46-즉시-객체-초기화)
    - [4.7](#47)
    - [4.8 함수 프로퍼티 - 메모리제이션 패턴](#48-함수-프로퍼티---메모리제이션-패턴)
    - [4.9 설정 객체 패턴](#49-설정-객체-패턴)
    - [장점](#장점)
    - [단점](#단점)
    - [4.10 커리](#410-커리)
    - [4.11 요약](#411-요약)
- [5장 객체 생성 패턴](#5장-객체-생성-패턴)
    - [5.1 네임스페이스 패턴](#51-네임스페이스-패턴)
    - [단점](#단점-1)
    - [범용 네임스페이스 함수](#범용-네임스페이스-함수)
    - [5.2 의존 관계 선언](#52-의존-관계-선언)
    - [5.3 비공개 프로퍼티와 메서드](#53-비공개-프로퍼티와-메서드)
    - [비공개(private) 멤버](#비공개private-멤버)
    - [특권 (privileged) 메서드](#특권-privileged-메서드)
    - [비공개 맴버의 허점](#비공개-맴버의-허점)
    - [객체 리터널과 비공개 멤버](#객체-리터널과-비공개-멤버)
    - [프로토타입과 비공개 맴버](#프로토타입과-비공개-맴버)
    - [비공개 함수를 공개 메서드로 노출 시키는 방법](#비공개-함수를-공개-메서드로-노출-시키는-방법)
    - [모둘패턴](#모둘패턴)
        - [모듈 패턴은 다음 패턴들을 여러 개를 조합한 것이다.](#모듈-패턴은-다음-패턴들을-여러-개를-조합한-것이다)

<!-- /TOC -->

## 1장

- 딱히 내용이 없는데 나중에 시간 있을때 정리하는 게 좋을듯

## 2장 기초

- 자바스크립트 코드를 작성하는 데 핵심이 되는 모범적인 관행과 습관, 패턴을 검토
- 전역변수 최소화
- 루프 내에서 `length`를 캐시해두고 사용
- 코등 규칙을 준수하는 것
- API 문서 작성, 동료 리뷰 진행, JSLint 실행
- 이런한 습관과 실천들을 익히면 좀더 훌룡하고 이해하기 쉽고 유지보수 하기도 쉬운 코드를 작성 할 수 있다.
- **_몇 달이나 몇년 지나서 다시 봐도 자랑스러운 코드 말이다._** ~~이말이 제일 감동...~~

### 2.1 유지보수 가능한 코드 작성

- 소프트웨어의 버그를 고치는 데는 비용이 든다.
- 버그가 공개적으로 출시된 제품 안에 숨어 들어간 경우에는 특히 비용이 커진다. ~~나 때문에 회사가 돈을 못버는듯...~~
- 발견 즉시 버그를 고칠수 있다면 가장 좋다. 코드가 어떤 일을 수행하는지가 머릿속에 아직 생생하기 때문이다. ~~나는 아닌데... 그래도 늦으면 더 힘든건 사실~~
- 시간이 흐른 다음에 코드를 다시 들여다 볼 때는 다음 과같은 이유로 시간이 든다.

  - 문제를 다시 학습하고 이해하는데 걸리는 시간
  - 이 문제를 해결하는 코드를 이해하는데 걸리는 시간

- 코드는 작성하는 것보다 읽는 데 더 많은 시간이 소요된다. ~~존나 공감~~

#### 요지보수 가능한 코드란 다음과 같은 특징을 지닌다.

- 읽기 쉽다
- 일관적이다
- 예측이 가능하다
- 한 사람이 작성한 것처럼 보인다.
- 문서화되어 있다.

### 2.2 전역 변수 최소화

- 자바스크립트는 함수를 사용하여 유효범위를 관리한다.
- 함수 안에서 선언된 변수는 해당 함수의 지역 변수가 되며 함수 외부에서는 사용할 수 없다.
- 반대로 전역 변수란 어떤 함수에도 속하지 않고 선언되거나, 아예 선언되지 않은 채로 사용되는 변수를 가르 킨다.
- 모든 자바사크립트 실행 환경에는 전역 객체(global object)가 존재한다.
- 어떤 함수에도 속하지 않은 상태에서 `this`를 사용하면 전역 객체에 접근하게 된다.
- 전역 변수를 생성하는 것은, 이 전역 객체의 프로퍼티를 만드는 것과 같다.
- 브라우저에는 전역 객체에 `window`라는 부가적인 프로퍼티가 존재하며, 전역 객체 자신을 가리킨다. (대개)

다음 코드는 브라우저 환경에서 전역 변수를 생성하고 이 변수에 접근하는 방법을 보여준다.

```javascript
myglobal = 'hello' //안티패턴
console.log(myglobal); //'hello'
console.log(window.myglobal); //'hello'
console.log(window['myglobal']); //'hello'
console.log(this.myglobal); //'hello'
```

### 전역 변수의 문제점

- **_전역 변수의 문제점은 자바스크립트 애플리켜이션이나 웹페지 내 모든 코드 사이에서 공윧된다는 점이다._** ~~모든 악몽의 씨발점~~
- 즉 모든 전역 변수는 동일한 전역 네임스페이스 안에 존재하 기 때문에, 애플리케이션 내의 다른 영역에서 목적이 다른 전역 변수를 동일한 이름으로 정의할 경우 서로 덮어쓰게된다.

#### 다음과 같은 경우

- 서드파티 자바스크립트 라이브러리
- 내가 작성한 자바스크립트 코드

위 같은 경우에 둘다 `result` 라는 전역 변수가 있을 경우 어떻게 될것인가?

- 따라서 다른 스크립트들과 한 페이지 안에서 사이좋게 공존하려면, 전역 변수를 최소한으로 사용해야한다.
- 이것을 해결 하기 위해 네임스페이스 패턴, 즉시 실행 함수를 활용하는 방법들에 대해서 다룬다.

#### 변수를 선언 할 경우 항상 var를 사용하기

- 자바스크립트 성격상 의로하지 않았더라도 전역 변수를 만들기가 너무 쉽다.

  - 자바스크립트에서 변수를 선언하지 않고도 사용할수 있다.
  - 자바스크립트에는 암묵적 전역(implied globals)라는 개념이 있다.
  - 즉 선언하지 않고 사용한 변수는 자동으로 젼역 객체의 프로퍼티가 되어 명시적으로 선언된 전역 변수와 별차이 없이 사용된다. **_예제 코드 참고_**

#### 예제 코드 안티패턴

```javascript
function sum(x, y) {
  // 안티패턴: 암묵적 전역
  result = x +y;
  return result;
}
```

- `result`는 `var`가 선언되지 않은 사앹로 사용되었다.
- 이 코드는 동장은 하지만 `result`는 네임스페이스에 `result`라는 변수가 남아 문제를 일르킬 수 있다.

#### 에제코드 바림직한 패턴

```javascript
function sum(x, y) {
  // var를 통한 변수 선언 (함수내의 지역 변수가된다.)
  vat result = x +y;
  return result;
}
```

#### var 선언을 빼먹었을 때의 부작용

- 암죽적 전역 벼수와 명시적으로 선언된 변수 사이에 존재하는 또 하나의 차이점
- delete 연산자를 사용하여 이 변수의 정의를 취소할 수 있는지 여부다.

  - var를 사용하여 명시적으로 선언된 전역 변수(함수에 속하지 않은 변수)는 삭제할 수 없다.
  - var를 사용하지 않고 생성한 암묵적 전역 변수는 (함수 안에서든 밖에서든 생성된)는 삭제 할 수 있다.

- **이는 암묵적 전역 변수가 엄밀히 말하면 변숙 아니라 전역 객체의 프로피터라는 사실을 보여준다.**

- **프로퍼티는 delete 연산자로 삭제할 수 있지만 변수는 그렇지 않다.**

#### 단일 var 패턴

**함수 상단에서 var 선언을 한번만 쓰는 패턴을 유용하고 시도해 볼만하다. 다음과 같은 이점을 갖는다.**

- 함수에서 필요로 하는 모든 지역 변수를 한군데서 찾을 수 있다.
- 변수를 선언하지 전에 사용할 때 발생하는 로직상의 오류를 막아준다. (히이스팅)
- 변수를 먼저 선언한 후에 사용한다는 사실을 상시시키기 때문에 전역 변수를 최소하 하는데 도움을준다.
- 코드량이 줄어든다. (작성량과 전송량 모두 줄어든다.)
- 무엇보다도 프로그래머에게 변수 선언을 패턴화 시키고 그것을 강제 시킨다는게 가장큰 의미인듯. ~~이건 내 생각~~

#### 단일 var 패턴 예제

```javascript
function func() {
  var
    a = 1,
    b = 2,
    sum = a + b,
    myobject ={},
}
```

- 변수를 선언할 때 초기값을 주어 초기화 하는 것 역시 좋은 습관이다.
- 문법 오류를 막을 수 있고,코드 가독성도 향상된다.
- 무엇 보다도 초기 값 없이 선언된 변수들은 모두 `undefined`라는 값으로 초기화된다.

#### 호이스팅 : 분산된 var 선언의 문제점

- 자바스크립트에서는 함수 내 여기저기서 여러 개의 `var`를 선언을 사용할 수 있지만
- 실제로는 모두 함수 상단에서 변수가 선언된 것과 동일하게 작동한다.
- **_이러한 동작 방식을 호이스팅 이라 한다._**
- 자바스크립트는 동일한 함수 안에 있는 변수는 `var`선언 전에 사용해도 이미 선언된 것으로 간주한다

#### 예제코드

```javascript
//안티패턴
name = 'global'; //전역변수
function func() {
  alert(name) //'undefined'
  var name = 'local';
  alert(name); //'local'
}
func();
```

- `global` -> `local` 순으로 호출될 거라 예상이 되겠지만
- 그러나 `undefined` -> `local` 순으로 출력된다.
- 첫번째 `alert`이 호출되는 시점에서 `name`이 아직 선언되지 않았으므로 전역 변수인 `name`을 바라볼것이라고 예상하겠지만 그렇지 않다
- `name`이 함수의 지역 변수로 선언되었다고 간주기하 때문이다. 선언문 자체는 그 다음에 나온다 해도 말이다.
- 즉 첫번째 `alert(name)`에 `name`은 함수내에 지역 변수로 선언된 것처럼 인식하고, `name`은 초기화 되어 있지 않기 때문에 `undefined`이라는 메세지를 출력하는 것이다.

#### 위의 예제코드는 아래와 동일하게 동작한다.

```javascript
name = 'global'; //전역변수
function func() {
  var name; // 변수에 값을 할당하지 않았음으로 undefined으로 인식된다.
  alert(name) //'undefined'
  name = 'local'
  alert(name); //'local'
}
func();
```

### 2.3 for 루프

### 일반적인 for 루프 패턴 예제

```javascript
//최적화 되지 않은 루프
for (var i = 0;, i < myarray.length; i++){
  // myarray[i]를 다루는 코드...
}
```

- 이 패턴의 문제점은 루프 순회시마다 배열의 length에 접근한다는 점이다.
- 따라서 for 루프를 좀더 최적화하기 위해서는 다음 예제처럼 배열의 `length`를 캐시해야한다.

```javascript
for(var i = 0; max = myarray.length; i < max; i++){
  // myarray[i]를 다루는 코드...
}
```

- 이렇게 하면 `length` 값을 한 번만구하고, 루프를 도는 동안에 이 값을 사용하게 된다.

### 2.4 for-in 루프

- `for-in` 루프는 배열이 아닌 객체를 순회할 때만 사용해야한다.
- 객체를 순회할가 아닐 경우는 `for`를 사용하는 것이 바람직하다. `for` 루프가 훨씬더 빠르기 때문이다.

### 2.6 switch 패턴

- 다음 패턴을 따르면 switch문의 가독성과 견고성을 향상시킬 수 있다.

```javascript
var inspect = 0,
    result = '';
switch (inspect) {
  case 0:
    result = 'zero';
    break;
  case 1:
    result = 'one';
    break;
  default:
    result = 'undefined'
}
```

- 각 `case`문을 `switch` 문에 맞추어 졍렬된다.
- 각 `case`는 명확하게 `break;`로 종료시킨다.
- 사응하는 `case`문이 하나도 없을 경우에도 정상적인 결과가 나올 수 있도록 `switch`문 마지막에 `default;`문을 작성한다.
- `break`문을 생략하여 통과 시키지 않는다.

### 2.7 암묵적 타입캐스팅 피하기

- 자바스크립트는 변수를 비교할 때 암묵적인 타입으로 캐스팅을 실행한다.
- `false == '0'` or `'' == 0` 비교가 `true`가된다.
- 암묵적인 타입캥스팅으로 인한 혼동을 막기 우해서는 항상 표현식의 값과 타입을 모두 `===` or `!==` 연산자를 사용해야한다.

```javascript
var zero = 0;
if(zero === false){
  // zero는 0이고 false가 아니기 때문에 이 블록은 실행되지 않는다.
}
//안티패턴
if(zero == false)
  // 이블록은 실행된다 암묵적인 타입캐스팅이 작동되기 때문에
```

### 2.8 코딩 규칙

- 코딩 규칙을 수립하고 준수하는 중요한 이유는 이를 통해 코드의 일관성이 유지되고 예측 가능해지며 읽고 이해하기가 훨씬 더 쉬워지기 때문이다.

### 들여쓰기

- JSLint로 대체 *

  ### 중괄호

- JSLint로 대체

### 생성자를 대문자로 시작하기

- 자바스크립트에는 클래스가 없지만 생성자 함수를 `new`와 함께 호출할 수는 있다.
- 생성자도 여전히 함수이기 때문에, 함수 이름만 보고 생성자로 쓸 함수 인지 일반 적인 함수인지 알아챌 수 있다는 도움이 된다.
- 다음 장에서는 생성자가 실제로 생성 자 처럼 동작호도록 프로그램상으로 강제할 수 있게 해주는 몇몇 패턴들을 다룰 것이다.

### 단어 구분

#### 함수경우

- `camle case`를 따른다

#### 변수

- `_`로 단어 구분점을 준다 ex) `var max_width;`
- 상수는 대문자와 `_`로 단어 구분저을 준다 ex) `var MAX_WIDTH;`

**_다양한 예제가 있었으나 나는 기본적으로 위에서 설명한 규칙을 따른다._**

### API 문서작성

- YUI DOC를 추천

## 3장 리터럴과 생성자

- 리터럴 표기법 패턴을 사용하면 좀더 정확하고 표현력이 풍부하면서도 에러율은 앉은 방식으로 객체를 정의할 수 있다.
- 이 장의 핵심은 생성자 사용을 자제하고 대신 리터럴 표기법을 사용하라는 것이다.

### 3.1 객체 리터럴

- 자바스크립트에서 `객체` 라고 하면 단순히 이름-값 쌍의 해시 테이블을 생각하면된다.
- 객체 리터럴 표기법은 이 처럼 필요에 따라 객체를 생성할 때 이상적이다.

```javascript
var dog = {};

// 프로퍼티 추가
dog.nmae 'Yun';

// 이번에는 메서드를 추가한다.
dog.getName = function(){
  return dog.nmae;
}
```

- 이 예제는 빈객체를 선언하고
- 프로퍼티와 메서드를 추가한다.
- 프로그램 생명주기 중 어느 때라도 다음과같은 일을할 수 있다.

  - 프로퍼티 값 변경
  - 프로포티나 메서드를 완전 삭제
  - 다른 프로파티나 메서드를 추가

### 객체 리터럴 문법

- 객체를 중공화 `{}`로 감싼다
- 객체 내의 프롶티와 메서드를 쉼표 `,`로 분리한다.
- 마지막에 이름-깂 쌍 뒤에 쉼표가들어가면 IE에서는 에러가 발생하므로, 마지막에는 `,`를 붙이지 않는다.

### 생성자 함수로 객체 생성하기

- 자바스크립트에서는 클래스가 없기 때문에 상당히 유연하다.
- 객체에 대해서 사전에 알아야 두러야하는 '청사진' 같은 것이 필요 없기 때문이다.
- 객체를 생설할 때는 직접 만든 생성자 함수를 사용할 수도 있고, `Object(), Date(), String()`등 내장 생성자를 사용할 수도 있다.

```javascript
// 객체 리터럴 사용
var car = {gose: 'far'};

// 다른 방법 - 내장 생성자 사용
// 경고: 이 방법은 인티패턴이다.

var car = new Object();
car.gose = 'far'
```

- 객체 리터럴 표기법의 이점은 더 짧다느 것이다.
- 객체란 그 저 변형가능한 해시에 불과하며 어떤 쪼리법에 의해 구워내야만 하는 특별한 것이 아님을 확실히 보여준다. (그냥 자바스크립트에서 객체는 키-벨류 라는 것을 설명하는 거같다)

### 객체 생성자의 함정

- 객체 리터럴을 사용하는 수 있는 상황에서는 `new Object()` 생성자를 쓸 이유가 없지만, 다른 사람이 작성한 레거시 코드를 물려받을 수도 있기 때문에 이 생성자의 기능 하나들ㄹ 알아둘 필요가 있다.
- 결국 생성자를 써서는 안 되는 이유이기도 하다.

### 3.2 사용자 정의 생성자 함수

- 객체 리터럴 패턴이나 내장 생성자 함수를 쓰지 않고, 직접 생성자 함수를 만들어 객체를 생성할 수도 있다.

```javascript
var adam = new Person('Admin');
adam.say(); // 'iam admin'
```

- 이 패터은 자바에서 `Person`이라는 클래스를 사용하여 객체를 생성하는 방식과 상당히 유사하다
- 그러나 문법은 비슷해도 클래스라는 것이 없으면 `Person`은 그저 보통함수일 뿐이다.

### 다음은 `Person` 생성자 함수를 정의한 예시이다.

```javascript
var Person = function(name){
  this.name =name;
  tihs.say = function (){
    return 'I am' + this.name;
  }
}
```

**`new` 와 함께 생성자 함수를 호출하면 함수 안에서 다음과 같은 일들이 일어난다.**

- 빈 객체가 생성된다. 이 객체는 this라는 변수로 참조할 수 있고, 해당 함수의 프로토타입을 상속받는다.
- this로 참조되는 객체에 프로퍼티와 메서드가 추가된다.
- 마지막에 다른 객체가 명시적으로 반환되지 않을 경우, this로 참조된 이 객체가 반환된다.

즉 이면에서 다음과 같이 진행된다고 할 수 있다.

```javascript
var Person = function (name) {
  // 객체 리터럴로 새로운 객체를 생성한다.

  // var this = {};

  // 프로퍼티와 메서드를 추가한다.
  this.name = name;
  this.say = function () {
    return 'I am' + this.name;
  };
  // this를 반환한다
  // return this
}
```

- 이 예제에서느 간다히 `say()`라는 메서드를 this에 추가했다.
- 결과적으로 `new Person()`을 호출할 때마다 메로이에 새로운 함수가 생성된다.
- `say()` 라는 메서드는 인스턴스별로 달라지는게 아니므로 이런 방식은 명백히 비효율적이다.
- 이 메서드는 Person의 프로토타입에 추가하는 것이 더 낫다

```javascript
Person.prototype.say = function () {
  return 'I am' + this.name;  
};
```

- 이어지는 장에서 프로토타입과 상속에 대해서 더 자세히 다루겠지만 여기서는 메서드와 같이 재사용되는 멤는 프로토타입에 추가해야한다는 점만 기억해두자.
- `var this ={}`는 빈 객체는 실제로는 텅 빈 것이 아니다.
- 이 객체는 Person의 프ㅡ로토타입을 상솔받는다. 즉 다음 코드에 더 가깝다. var tihs = Object.create(Person.prototype);

### 3.3 new를 강제하는 패턴

- 생성자란 new와 함께 호출될 뿐 여전히 별다른 것 없는 함수에 불과하다
- 그렇다면 생성자를 호출할 때 new를 빼먹으면 어떻게 될까?
- 문법 요루나 런타임 에러가 발생하지는 않는다.
- 하지만 논리적인 오류가 생겨 예기치 못한 결과가 나올수 있다
- new를 빼먹으면 생성자 내부의 this가 전역 객체를 가르키게 되기 때문이다. (브라우저에서는 this가 window를 가리키게 된다.)
- 셍상지 내부에 this.member와 같은 코드가 있을 때 이 생성자를new 없이 호출하면 실제로는 전역 객체에 member라는 새로운 프로포티가 생성된다.
- 이 프로퍼티는 window.member 또는 member를 통해 접근할 수 있다
- 전역 네임스페이스가 항상 깨긋하게 유지해야하기 때문에 이런 동작은 정말 바람직하지 않다.

### 예제

```javascript
// 생성자
function Waffle() {
  this.taster = 'yun';
}

// 새로운 객체
var test_msg = New Waffle();
console.log(typeof test_msg); // 'object'
console.log(test_msg.taster); // 'yun'

// 안티패턴 'new'를 생략했다.
var test_msg =  Waffle();
console.log(typeof test_msg); // 'undefined'
console.log(window.taster); // 'yun'
```

- ECMAScript 5에서는 이러한 동작을 방지하기 위해서 스크릭트모드에서 this가 전역 객체를 가리키지 않도록 했다.

### 명명 규칙

- 가장 간단한 대안은 앞 장에서 다룬 명명 규칙을 사용하는 것이다.
- 생성자 함수의명의 첫글자를 대문자로 작성한다

### that 사용

- 명명 규칙을 따른 것도 꽤 도움이 되지만 이는 올바른 동적 방식을 권할뿐 강제하지는 못한다
- 생성자가 항상 생성자로 동작하도록 해주는 패턴을 살펴보자.
- this에 모든 맴버를 추가하는 대신, that에 모든 멤버를 추가한 후 that을 반환하는 것이다.

```javascript
function Waffle(){
  var that = {};
  that.taster = 'yun';
  return that;
}
```

- 간단한 객체라면 that이라는 지역 변수를 만들 필요 없이 객체 리터럴을 통해 객체를 반환 해도된다

  ```javascript
  function Waffle(){
  return{
    taster : 'yun'
  };
  }
  ```

### 3.4 배열 리터럴

- 자바스크립트의 배열은 이 언어 내 다른 모든것들과 마찬가지로 객체이다.

```javascript
// 모두 안티패턴이다.
var a = new Array('a', 'b', 'c');

var a = new Array['a', 'b', 'c'];

console.log(typeof a); // 배열로 객체이기 때문에 'object'가 출력된다.
console.log(a.construertor === Array); // true;
```

### 배열 리터럴 문법

- 배열 객체 리터럴 문법은 틀별한 것이 없다
- 각 원소는 쉼표로 분리하고 전체 목록을 대확호로 감싸준다 ex) `var array = ['a', 'b', 'c'];`

### 배열 생성자의 특이성

```javascript
// 한 개의 원소를 가지는 배열
var a = [3];
console.log(a.length); // 1
console.log(a[0]); // 3

// 세 개의 원소를 가지는 배열
var a = new Array(3);
console.log(a.length); // 3
console.log(typeof a[0]); // 'undefined'
```

### 3.5 에러 객체

```javascript
try{
  // 에러를 발생시킨다.
  throw{
    name: 'MyErrorType', // 임의의 에러 타입
    message: 'oops',
    extra: 'This was rather embarrassing',
    remedy: 'genericErrorHandler', // 에러를 처리할 함수
  };
} catch (e){
  // 사용자에게 공지한다.
  alert(e.message); //'oops'
  e.remedy(); //훌룡허개 애로를 처리한다
}
```

### 요약

- 객체 리터럴 표기법 - 이름-값 쌍을 쉼표로 분리하고 괄호로 감싸 객체를 만든다
- 생성자 함수 - 내장 생성자 함수와 사용자 정의 생성자를 살펴보았다. 내장 생성자의 경우, 대개는 대응하는 리터럴 표기법을 쓰는 것이 좋다
- 생성자 함수가 항상 new와 함께 호출된 것처럼 동작하도록 보장하는 방법을 살펴보았다.
- 배열 리터럴 표기법
- 에러 객체 throw를 객체 리터럴 방법으로 처리하는 것을 살펴보았다.

## 4장 함수

- 자바스크립트는 함수를 다양한 방법으로 사용한다.
- 이 장에서는 자바스므립트에서 함수를 정의하는 다양한 방법들과 함수 표현식 그리고 함수 선언문에 대해서 알아본다
- 지역 유효범위와 변수 호이스팅이 어떻게 동작하는지 살펴 본다
- 함수에 더 나은 인터페이스를 제공하는 API, 전역 변수를 덜 사용하는 코드 초기화, 불필요한 작업을 회피해 성능에 도움을 주는 여러가지 패턴들에 대해 배운다

### 4.1 배경지식

- 자바스크립트의 함수를 특별하게 만드는 두 가지 중요한 특징이있다.

  - 일급객체 , 유효범위를 제공한다

#### 함수는 다음과 같은 특징을 가지는 객체다.

- 런타임, 즉 프로그램 실행 중에 동적으로 생성할 수 있다.
- 변수에 할당할 수 있고, 다른 변수에 참조를 복사할 수 있으며, 확장이가능하고, 몇몇 특별한 경우를 제외하면 삭제할 수 있다.
- 다른 함수의 인자로 전달할 수 있고, 다른 함수의 반환 값이 될 수 있다.
- 자기 자신의 프로퍼티와 메서드를 가질 수 있다.

#### 함수도 객체이다

```javascript
// 안티패턴
var add = new Fuction('a ,b' 'retrun a + b');
add(1, 2) //3
```

- 이코드에서 `add()`는 생성자를 통해서 만들었기 때문에 객체라는 사실이 자명하다.
- 그러나 `Fuction()` 생성자의 사용은 정말 좋지 않다
- 코드가 문자열로 전달되어 평가되기 때문이다.
- 함수가 유효범위를 제공한다는 것이다. 자바스크립트에서는 중괄호`({})` 지역유효범위를 제공한다는 것이다.
- **_달리 말해서 블록이 유효범위를 만들지 않는다. 단지 함수 유혀범위가 있을 뿐이다._**
- 어떤 변수이건 함수 내에서 var로 정의되면 지역 변수이고 함수 밖에서는 참조할 수 없다.
- **_여기서 중요한것은 `if, for, while`문 내에서 `var`로 정의해도, 이 변수가 `if, for, while`의 지역 번수가 되지 않는다는 뜻이다._** ~~나는 정말 자바스크립트 헛공부 했다...~~
- **_변수는 해당 블럭을 감싸는 함수가 있을 때만 지역 변수가 된다._**
- 2장에서 업근 했듯이 전역 변수를 최소하하는 것이 좋기 때문에 변수의 유효범위를 잘 관리하기 위해서는 함수는 없어서는 안될 존재이다.

#### 용어 정리

- 패턴에 대해 이야기할 때 합의 돈 정확한 이름을 사용하는 것이 코드 자체만큼이나 중요하다
- 그러므로 함수를 정의하는 코드와 관련된 용어에 대해 이야기해보자.

#### 기명함수 표현식 (named function expression)

```javascript
// 기명함수표현식
var add = function add(a, b) {
  retrun a + b;
};
```

- 이 코드는 기명함수 표현식 (named function expression)을 사용한 함수를 보여준다.

#### 무명함수 표현식 (unnamed function expression)

```javascript
// 함수 표현식 (또는 익명함수)
var add = function(a, b){
  retrun a + b;
}
```

- 함수 표현식 이라고도 표현하며, 익명함수라는 말로도 많이 쓰인다.

#### 차이점

- 유일한 차이점은 함수 객체의 `name` 프로퍼티가 빈 문자열이 된다는 것이다.
- `name` 프로퍼티는 ECMA 표준이 아니라 언어의 확장기능이지만 많은 실행 환경에서 폴넓게 사용된다.
- 기명함수 표현식같은 경우에는 `add.name` 프로퍼티에 `add`라는 값을 가지게된다.
- 파이어버그와 같은 디버거를 사용할 때, 함수 안에서 자기 자신을 재귀적으로 호출할 때 유용하다.
- 이런 용도로 쓸 게 아니라면 그냥 샐략해도된다.

#### 함수 선언문

```javascript
function foo() {
  // 함수 본문
}
```

- 함수 선언문은 다른 언어들의 함수 사요과 비슷하다.
- 문법적인 면에서, 함수 표현식의 결과를 벼누에 할당하지 않을 경우(이러한 문법을 콜백 패턴이라고 한다. 이 장의 다음 부분에서 다룬다)~~이게 무슨 말인지 이해가잘...저게 콜백이라고???~~
- 기명 함수 표현식과 함수 서넌문은 비슷해 보인다. 때로는 함수를 생성하는 문맥을 보지 않고서는 함수 선언문과 이름이 지정된 함수를 구분할 수 있는 방법이 없다.
- 세미콜론이 붙는지 여부에 따라 그 둘의 문법적인 차이점이 있다.
- 함수 선언문에는 세미클론이 필요하지 않다

#### 선언문 vs 표현식 : 이름과 호이스팅

- 그렇다면 함수 선언문과 함수 표현식 중 어떤것을 사용해아할까?

- 함수 선언문은 전역 유효범위나 다른 함수의 본문 내부, 즉 프러그램 코드에서만 쓸 수 있다.

- 변수나 프로퍼티에 할당할 수 없고, 함수 호출시 인자로 함수를 넘길 때도 사용할 수 없다. ~~두 번째는 이해가 잘 안가네...~~

- 그렇다면 언제 함수 선언문을 사용할 수 있을까?

- 다음 예제에서 함수 `foo(), bar(), local()`은 모두 함수 선언문 패턴으로 정의도있다.

```javascript
// 전역 유효범위
function foo() {}
function local() {
  // 지역 유효범위
  function bar(){}
  retrun bar;
}
```

#### 험수의 name 프로퍼티

- 함수를 정의하는데 패턴을 선택할 때는 읽기 전욕 name 프로퍼티를 쓸 일이 있는지도 고려해보야야한다.
- 거듭 말하지만 name 프로퍼티는 표준은 아니지만 많은 실행 환경에서 사용 가능하다.

```javascript
function foo() {} // 함수 선언문
var bar = function () {} // 익명함수 표현식
var baz = function baz() {} // 기명함수  표현식

foo.name; // 'foo'
bar.name; // ''
baz.name; // 'baz'
```

- name 프로퍼티는 파이어버그(~~이게 뭐지? 알아보자~~)나 다른 디버거에서 코드를 디버깅할 때 유용하다.
- 함수 내에서 발생한 에러를 보여주어야 할 때 디버거가 name 프로퍼티를 값을 확인 하여 이름표로 쓸 수 있기 때문이다.

#### 함수 호이스팅

- 앞선 논의를 보고 함수 익명함수와 기명함수 펴햔식의 동작 방식이 겅의 동일하다고 결론지었을지도 모르겠다. 그러나 완전히 같지는 않다.
- 모든 변수는 함수 본문 어느 부분에서 선언되더라도 내부적으로 함수의 맨 윗부분으로 끌어올려 진다.
- 함수 또란 결국 변수에 할당되는 객체이기 때문에 동일한 방식이 적용된다.
- 함수 선언문을 사용하면 변수 선언뿐 아니라 함수 정의 자체도 호이스팅 되기 때문에 자칫 오류를 만들어 내기 쉽다.

```javascript
// 안티패턴이다.
// 전역 함수

function foo(){
  alert('global foo');
}

function bar(){
  alert('global bar');
}

function hoistMe() {
  console.log(typeof foo); // 'function'
  console.log(typeof bar); // 'undefined'

  foo(); // 'local foo'
  bar(); // TypeError : bar is not a function

  // 함수 선언문
  // 함수 'foo'와 정의된 함수 모두 호이스팅된다.
  function foo() {
    alert('local foo');
  }

  // 함수 표현식
  // 변수 'bar'는 호이스팅 되지만 정의된 함수는 호이스팅 되지 않는다.
  var bar = function(){
    alert('local bar');
  };
}
hoistMe();
```

- `hoistMe()` 함수 내에서 foo, bar를 정의하면, 실제 변수를 정의한 위치와 상관 없이 끌어올려져 전역 변수인 foo와 bar를 덮어쓰게 된다.
- 그런데 지역 변수 foo()는 나중에 정의되어 상단으로 호이스팅되어 정상 동적하는 반면
- bar()의 정의는 호이스팅되지 않고 선언문만 호이스팅 된다. 때문에 bar()의 정의가 나오기전 까지는 undefined 상태이고 따라서 함수로 사용할 수도 없다.

#### 마무리

- 함수는 객체이다.
- 함수는 지역 유효범위를 제공한다.

### 4.2 콜백 패턴

- 함수는 객체다. 즉 함수를 다른 함수에 인자로 전달할 수 있다.

```javascript
function writeCode (callback){
  // 어떤 작업을 수행한다.
  callback();
  // ....
}

function introdueBugs() {
  // 버그를 만든다.
}

writeCdoe(introdueBugs);
```

- `introdueBugs()`가 `writeCdoe()`의 인자로 괄호 없이 전달된 사실을 눈여겨 보자
- 광호를 붙이면 함수가 실행되는데 이 경우는 함수의 참조담ㄴ 전달하고 실행은 추후에 적절한 시점에 `writeCdoe()`가 해줄것이기 때문에 괄를 덧붙지이 않았다.

#### 라이브러리에서의 콜백

- 콜백은 라이브러리를 설계할 때 유효한 간단하고 강력한 패턴이다.
- 소프트웨어 라이브러리에 들어갈 코드는 가능한 범용적이고 재사용할 수 있어야한다
- 콜백은 이런 일반화에 도움이이 된다.
- 생각할 수 있는 모둔 기능을 예측하고 구현할 필요는 없다
- 이는 라이브러리를 쓸데 없이 부풀릴 뿐이고 대부분의 사용자는 그런커다란 기능의 덩어리를 절대 필요로 하지 않는다
- 대신에 핵심 긴능에 집중하고 콜백의 형태로 연결과리를 제공하라
- 콜백 함수를 활요하면 좀더 쉽게 라이브러리리 메서드를 확장하고 가다담을 수 있다.

### 4.3

- 함수는 객채이기 때문에 반환 값으로 사용 될 수 있다.
- 즉 함수의 실행 결과로 꼭 어떤 데이터 값이나 배열을 반환할 필요는 없다는 뜻이다.
- 보다 특화된 함수를 반환할 수있고, 입력 값에 따라 필요한 함수를 새로 만들어낼 수도 있다.
- 간단한 예제를 보자. 이 함수는 일회적인 초기화 작업을 수행한 후 반환 값을 만든다. 반환 값은 실행 가능한 함수이다.

```javascript
var setup = function () {
  alert(1);
  return function () {
    alert(2);
  };
};
// setup 함수를 사용
var my = setup(); // alert으로 1이 출력된다.
my(); // alert으로 2가 출력된다.
```

- `setup()`은 반환더ㅣㄴ 함수를 감싸고 있기 때문에 클로저를 생성한다.
- 클러저는 반환 되는 함수에서 접근할 수 있지만 코드 외부에서 접근할 수 없기 때문에 비공개 데이터를 저장을 위해 사용할 수 있다.
- 매번 호출할 때마다 값을 증가하는 카운터를 예제로 들수 있다.

```javascript
var setup = function(){
  var count = 0;
  return function(){
    return (count += 1);
  };
};

// 사용방법
var next = setup;
next(); // 1을 반환
next(); // 2을 반환
next(); // 3을 반환
```
- next를 통해서만 `var count` 값을 증가시킬수 있다.
- 외부에서 `var count`에 접근할 방법이 없기 때문에 안전하다.

### 4.4 자기 자신을 정의하는 함수

- 함수는 동적으로 정의할 수 있고 변수에 할당할 수 있다.
- 새로운 함수를 만들어 이미 다른 함수를 가지고 있는 변수에 할당하면, 새로운 함수가 이전 함수를 덮어쓰게 된다.
- 어떤 면에서는 이전 함수 포인터가 새러운 함수를 가르키도록 재사용하는 것이다.
- 이런 일을 이전 함수의 번문 내에서 할 수 있다. 이 경우는 함수는 자기 자신을 새로운 구현으로 덮어쓰고 재정의 한다.

```javascript
var scareMe = function () {
  alert('Boo!');
  scareMe = function(){
    alert('Double Boo!') ;
  };
};

// 자기 자신을 정의하는 함수를 사용
scareMe(); // Boo
scareMe(); // Double Boo
```

- 이 패턴은 함수가 어떤 초기화 준비 작업을 단 한번만 수행할 경우에 유용하다.
- 불필요한 작업을 반복할 이유가 없기 때문에 함수는 일부는 더이상 쓸모가 없다.
- 이런 경우 함수가 자기자신을 재정의하여 구현 내용을 갱신할 수 있다.
- 가단히 말해서 재정의된 함수의 작업량이 적기 때문에 이 패턴은 애플리케이션 성능에 확실히 도움이된다.

### 4.5 즉시 실행함수

- 즉시 실행 함수 패턴은 함수가 선언되자마자 실행되도록 하는 문법이다. 다음 예제를 보자

```javascript
(function (){
  alert('run');
  })();
```

- 함수를 함수 표현 식으로 표현한다.
- 함수가 즉시 실핼될수 있도록 마지막에 쌍괄호를 추가한다
- 전체 함수를 괄호로 감싼다

### 즉시 실행 함수 매개변수

```javascript
(function (name, age){
  console.log(name + age);
})('yun', 23);
```

- 일반적으로 즉시 실행 함수에 대한 인자를 너무 많이 전달하지 않는 것이 좋다.
- 코드 동작을 이해하려고 계속 코드의 맨윗부분과 아랫부분을 사이을 오가며 스코롤하기 부담스럽기 때문이다.

### 즉시 실행 함수의 반환 값

```javascript
var getResult = (function (){
  var res = 2 + 2;
  return function (){
    return res;
  }
})();
```

- 즉시 실행함수가 함수를 반환하고 이 반환 값이 `getResult`라는 변수에 할당된다.
- 이 함수는 즉시 실행 함수에서 미리 정의된 `res`라는 값을 반환한다.

### 장점과 사용 방법

- 즉시 실행 함수 패턴은 폭넓게 사용된다.
- 전역 변수를 남기지 않고 상당량의 작업을 할수 있게 해준다.
- **_선언된 모든 변수는 스스로를 호출하는 함수의 지역변수가 되기 때문에 임시 변수가 전역 공간을 어지럽힐 까봐 걱정하지 않아도된다._**

### 4.6 즉시 객체 초기화

- 전역 유효범위가 난잡해지지 않도록 보호하는 또 다른 방법을 앞서 설명한 즉시 실행 함수 패턴과 비슷한 즉시 객체 초기화 패턴이다.
- 이 패턴은 객체가 생성된 즉시 `init()` 메서드를 실행해 객체르 사용한다.
- `init()` 함수는 모든 초기화 작업을 처리한다.

```javascript
({
  // 여기에 설정 값(설정 상수)들을 정의할 수 있다.
  maxwidth : 600,
  maxheigth : 400

  // 유틸리티 메서드 또한 정의할 수 있다.
  gimmerMax :function () {
    return tihs.maxwidth + 'x' + tihs.maxheigth;
  },

  // 초기회
  init : function (){
    console.log(tihs.gimmerMax());
  }
}).init();
```

- 문법적인 면에서 이 패턴은 객체 리터럴을 사용한 일반적인 객체 생성과 똑같이 생각하면된다
- 객체 리터럴도 괄호로 감싸는데, 이는 자바스크립트 엔진이 중괄호를 코드블록이 아니라 객체리털로로 인식하도록 지시하는 역할을 한다
- 그런 다음 닫는 괄호에 이어 `init()` 메서드를 즉시 호출한다.

- 이 패턴의 장점은 즉시 실행 함수 패턴의 장점과 동일하다.

- 단 한 번의 초기화 작업을 실행하는 동안 전역 네임스페이스를 보호할 수 있다.

- 코드를 익멱함수로 감싸는 것과 비교하면 이 패턴은 문법적으로 신경써야 할 부분이 좀더 많은 것처럼 보일수도 있다.

- 그러나 초기화 작업이 좀더 복잡해진다면 전체 초기화 절차를 구조화하는데 도움이된다

- 예를 들어 비공개 도우미 함수를 임시 객체의 프로퍼티로정의하면, 즉시 실행 함수를 여기저기 흩어 놓고 쓰는 것보다 훨씬 구분하기 쉽다.

### 4.7

### 4.8 함수 프로퍼티 - 메모리제이션 패턴

- 함수는 객체이기 때문에 프로퍼티를 가질 수 있다.
- 사실 함수는 처음부터 프로퍼티를 가지고있다.
- 언제든지 함수에 사용자 정의 프로파티를 추가할 수 있다.
- **_함수에 프로퍼티를 추가하여 결과를 캐시한다음 다음 호출 시점에 복잡한 연산을 반벅핮 않을 수 있다._** ~~이게 핵심~~

```javascript
var myFunc = function (param) {
  if(!myFunc.cache[param]){
    var result = {};
    // ...비용이 많이 드는 수행....
    myFunc.cache[param] =result;
  }
  return myFunc.cache[param];
};

// 캐시 저장공간
myFunc.cache ={};
```

- `myFunc` 함수에 `cache` 프로퍼티를 생성한다
- 이 프로퍼티는 일 반적인 프로퍼티 처럼 `myFunc.cache`와 같은 형태로 접근할 수 있다.
- `cache` 프로퍼티는 함수로 전달된 `parma` 매게변수를 키로 사용하고 계산된 결과를 값으로 가지는 객체 (해시)이다.
- 결과 값은 필요에 따라 복잡한 데이터 구조로 정의할수도 있다.
- 만약 메게 변수가 복잡하다면 일반적으로 직렬화 하여 해결할 수 있다.
- JSON 문자열로 직렬화하고 이 문자열을 `cache` 객체에 키로 사용할 수 있다.

```javascript
var myFunc = function () {

  var cachekey = JSON.stringify(Array.prototype.slice.call(arguments));
  var result;

  if(!myFunc.cache[cachekey]){
    result = {};
    // ... 비용이 많은 드는 수행 ...
    myFunc.cache[cachekey] = result;
  }
  return myFunc.cache[cachekey];
};

// 캐시 공간
myFunc.cache = {};
```

### 4.9 설정 객체 패턴

- 설정 객체 패턴은 좀더 깨긋한 API를 제공한는 방법이다.
- 라이브러리나 다른 프로그램에서 사용할 코드를 만들 때 특히 유용하다.
- 넘겨야할 메게변수가 많을 경우

```javascript
var  conf = {
  username : 'yun',
  age : 27,
  sex: 'M',
}
function addPerson(conf) {
  conf.name // yun
  conf.age // 27
  conf.sex // M
}
```

### 장점

- 매게변수와 순서를 기억할 필요가 없다.
- 선택적인 매게변수를 안전하게 생락할 수 있다
- 일기 쉽고 유지보수가 편리하다

### 단점

- 매게변수의 이름을 기억해야한다
- 프로피터 이름은 압축되지 않아 코드가 길어진다.

### 4.10 커리

### 4.11 요약

- 자바스크립트에서 함수를 제대로 이해하고 적합하게 사용하는 일을 매우 중요하다.
- 이 장은 함수에 관한 배경지식과 용어정리를 다루었다
- 자바스크립트에서 함수의 중요한 두 가지 특징에 대해 배웠다

  1. 함수는 일급 객체다. 값으로 전달 될수 있고, 프로퍼티와 메서드를 확장할 수 있다.
  2. 함수는 지역 유효범위를 제공한다. 다른 중골화 묶음은 그렇지 않다. 로컬 변수의 선언은 로컬 유효범위오 맨 윗부분으로 호이스팅된다는 점도 기억해두어야 한다.

- 함수를 생성하는 문법에는 다음과 같은 것들이 있다.

  1. 기명함수 표현식
  2. 함수 표현식 (위와 동일하지만 이름만 없는것 익명함수) 익명함수라고도 한다.
  3. 함수 선언문. 다른 언어의 함수 문법과 유사하다.

- 함수 배경지식과 문법을 다룬 후, 여러 가지 유용한 패턴을 익혔다.

  1. API 패턴

    1. 콜백 패턴 - 함수를 인자로 전달한다.
    2. 설정 객체 - 함수에 많은 수의 매게변수를 전할할 때 통제를 벗어나지 않도록 해준다
    3. 함수 반환 - 함수의 반환 값이 또 다시 함수 있수도 있다.
    4. 커링 - 원본 함수와 매개변수 일부를 물려받아 새로운 함수를 생성한다.

- 초기화 패턴 - 웹페지와 애플리케이션에서 매우 흔히 사용되는 초기화 설정을 작업, 전역 네임스페이스를 어지럽히지 않고도 임시 변수를 사용해 좀더 깨긋하고 구조화된 방법으로 수행할 수 있게 도와준다.

  - 즉시실행 함수 - 정의도자마자 실행된다.
  - 즉시 객채 초기화 익명 객체 내부에서 초기화 작업을 구조화한 다음 즉시 호출할수 있는 메서드를 제공한다
  - 초기화 시점 분기 - 최초 코드 실행 시점에 코드를 분기하여, 애플리켜이션 생명 주기 동안 계쏙해서 분기가 발생하지 않도록 막아준다.

- 성능 패턴 - 코드의 실행 속도를 높이는 데 도움을 준다.

  - 메모제이션 패턴 - 함수 프로퍼티를 사용해 계산된 값을 다시 계산되지 않도록 한다.
  - 자기 선언 함수 - 자기 자신을 덮어씀으로써 두 번째 호출 이후부터는 작업량이 줄어들게 만든다.


## 5장 객체 생성 패턴
* 자바스크립트에서는 객체 리터럴이나 생성자 함수를 사용하여 아주 쉽게 객체를 마들 수 있다.
* 이 장에서는 좀더 나아가 객체를 생성하는 또다른 패턴들을 살펴볼것이다.
* 자바스크립트 언어는 간단하고 평이하다. 다른 언어에서는 네임스페이스나 모듈 패키지, 비공개 프로퍼티, 스택틱 맴버 등의 기능이 익숙하고 당연할지 몰라도, 자바스크립트에서는 이런것들을 위한 별도의 문법이 거의 없다.
* 이 장에서는 이러한 기능들을 구현하거나 대체하거나 또다른 관점에서 바라볼 수 있게 해주는 범용적인 패턴들에 대해 알아본다.
* 네임스페이스 패턴, 의존 관계 선언, 모듈 패턴, 샌드박스 패턴 등은 애플리케이션 ㅋ드를 정리하고 구조화할 수 있게 도와주고 암묵적 전역의 영향력을 약화시킨다.
* 비공개 맴버와 특권 맴버, 공개/비공개 스태틱 맴버, 객채 상수, 체이닝에 대해서도 다루고, 클래스와 비슷한 방식으로 생성자를 정의하는 방법도 하나 살펴본다.

### 5.1 네임스페이스 패턴

* 네임스페이스는 프로그램에서 필요로 하는 전역 변수의 개수를 줄이는 동시에 과도한 접두어를 사용하지 않고도 이름이 겹치지 않게 해준다.
* 자바스크립트 언어 문법에 내장되어 있지는 않지만, 네임스페이스는 꽤 쉽게 구현할 수 있는 기능이다.
* 수많은 함수, 객체, 변수들로 전역 유효범위를 어지럽히는 대신, 어플리케이션이나 라이브러리를 위한 전역 객체를 하나 만들고 모든 기능을 이 객체에 추가하면된다.

```javascript
// 수정전 : 전역변수 5 모두 안티패턴이다.

// 생성자 함수 2개
function Parent(){}
function Child(){}

// 변수 1개
var some_var = 1;

// 객체 2개
var module = {};
module.data = {a: 1, b: 2};
var modulo2 ={};
```

* 위와 같은 코드를 리펙토링하기 위해서는 애플리케이션 전욕 전역 객체, 이를 MYAPP를 생성한다.
* 그런 당므 모든 함수와 변수를 이 전역 객체의 프로퍼티로 변경한다.

```javascript
// 수정후 : 전역변수 1개

var MYAPP = {}; // 전역 객체 1개

//  생성자
MYAPP.Parent = function(){}
MYAPP.Child = function(){}

// 변수 1개
MYAPP.some_var = 1;

// 객체 컨테이너
MYAPP.modules = {};

// 객체들을 컨테이너 안에 추가한다.
MYAPP.modules.modules1 = {};
MYAPP.modules.modules1.data = {a: 1, b: 2};
MYAPP.modules.modules2= {};
```
* 전역 네임스페이스 객체의 이름은 애플리케이션 이름이나 라이브러리 이름, 도메인명, 회사명 중에서 선택할 수 도있다.
* 흔히 코드를 읽는 사람 눈에 띄도록 전역 객체 이름은 모두 대문자로 쓰는 명명 규칙을 사용하기도한다.(이 규칙은 상슈둘을 쓸 때도 사용된다는 점에 주의하라)
* 코드 내의 이름 충돌 뿐만아니라 이 코드와 같은 페이지에서 존재하는 자바스크립트 라이브러니나 위짓등 서드파티코드와 이름과도 충돌을 방지해준다.

### 단점
* 모든 변수와 함수에 접두어를 붙여야 하기 때문에 전체적으로 코드량이 약간 많아진다.
* 전역 인스턴스가 단 하나뿐이기 때문에 코드의 어느 한 부분이 수정되어도 전역 인스턴스를 수정하게된다. 즉나머지 기ㅡㅇ들도 갱신된 상태를 물려받는다.
* 이름이 중첩되고 길어지므로 프로퍼티를 판별하기 위한 검색 작업도 글고 느려진다.

### 범용 네임스페이스 함수
* 프로그램의 복잡도가 증가하고 코드의 각 부분들이 별개의 파일로 분리되어 선택적으로 문서에 포함하게 되면 어떤 코드가 특정 네임스페이스나 그 내부의 프로퍼티를 처음으로 정의한다고 가정하기가 위험하다.
* 네임스페이스에 추가하려는 프로퍼티가 존재할 수도 있고 따라서 내용을 덮어쓰게 될지도 모른다.
* 그러므로 네임스페이스를 생성하거나 프로퍼티를 추가하기 전에 먼저 이미 존재하는지 여부를 판단하는것이 최선이다.

```javascript
// 위험하다
var MYAPP = {};

// 개선안
if( typeof MAPP = 'undefined'){
  var MYAPP = {}
}

// 또는 더 짭게 쓸 수 있다.

var MYAPP = MYAPP  || {};
```

* 이렇게 추가되는 확인 작어 때문에 상당량의 중복 코드가 생겨날수 있다.
* 이 과정은 이해가 잘안가고 불필효 한거같아 생략했다.

### 5.2 의존 관계 선언
* 추후에 추가

### 5.3 비공개 프로퍼티와 메서드

* 자바 등 다른 언어와 달리 자바스크립트에는 `private, protected, public` 프로퍼티와 메서드를 나타내는 별도의 문법이 없다.
* 객체의 모든 맴버는 public으로 된다.

```javascript
var myobj = {
  myprop : 1,
  getProp : function () {
    return this.myprop
  }
}

console.log(myobj.myprop); // 'myprop'에 공개적으로 접근 가능
console.log(myobj.getProp()); // getProp() 역시 접근 가능
```

### 비공개(private) 멤버

* 비공개 맴버에 대한 별도의 문법은 없지만 클로저를 사용해서 구현할 수 있다.
* 생성자 함수 안ㅇ에서 클로저를 만들면, 클로저 유효범위 안의 변수는 생성자 함수 외부에 노출되지 않겠지만 객체의 공개 메서드 안에서는 쓸 수 있다.
* 즉 생성자에 객체를 반환할 때 객체의 메서드를 정의하면 이 메서드 안에서 비공개 변수에 접근할 수 있다.

```javascript
function Gadget (){
  var name = 'yun' // 비공개 맴버

  this.getName = function(){ // 공개 함수
    return name;
  };
}
var toy = new Gadget();
console.log(Gadget.name; //'undefined' 비공개 멤버 접근 불가능
console.log(Gadget.getName()); // 'yun' 공개 메서드 접근 가능
```

* 보다시피 자바스크립트에서도 쉽게 비공개 멤버를 구현할 수 있다.
* 비공개로 유지할 데이터를 함수로 감싸기만 하면된다
* ***이 데이터를 함수의 지역 변수로 만들면, 함수 외부에서 접근할 수 없다.***

### 특권 (privileged) 메서드
* 특권 메서드라는 개념은 특정한 문법과 관련이 없다.
* 단지 비공개 멤버에 접근권한을 가진 공개 메서드를 가르키는 이름을 뿐이다.
* 특별한 접근권한을 가지고 있기 때문에 특권 메서드라 한다.

### 비공개 맴버의 허점

* 비공개 멤버를 유지하는 게 관건이라면, 다음과 같은 경우에 대해서 신경을 써야한다.

* 이해가 안되 추후에 정리...

### 객체 리터널과 비공개 멤버

```javascript
var myobj; // 이 변수에 객체를 할당할 예정이다.

(function () {
	// 비공개 멤버
	var name = 'My, oh my',

	// 공개될 부분을 구현한다.
	// var를 사용하지 않다는 데 중의하라

	myobj = {
		//특권 메서드
		getName = function () {
			return name;
		}
	};

})();
myobj.getName(); // 'my, oh my'
```
* 비공개 데이터를 함수로 감싼다
* 객체리털럴 익명 즉시 실행함수를 추가하여 클로저를 만든다.
* 이 에제는 곧 살펴보게 될 모듈 패턴의 기초가 되는 부분이다.

### 프로토타입과 비공개 맴버

* 생성자를 사용하여 비공개 멤버를 만들 경우, 생성자를 호출하여 새로운 객체를 만들 때마다 비공개 멤버가 매번 재생성된다는 단점이있다.
* 사실상 생상저 내부에 this에 멤버를 추가하면 항상 이런 문제가 발생한다.
* 이러한 중복을 업애고 메모리를 절약하려면 공통 프로퍼티와 메서드를 생성자의 prototype 프로퍼티를 추가해야한다.
* 이렇게 하면 동일한 생성자로 생성한 모든 인스턴스가 공통된 부분을 공유하게된다.
* 감춰진 비공개 멤더들도 모든 인스턴스가 함께 슬 수 있다.
* 이를 위해서는 두 가지 패턴, 즉 생성자 함수 내부에 비공개 맴버를 만든 패턴과 객체 리터널로 비공개 맴버를 만드는 패턴을 함께 써야한다.
* 왜냐하면 prototype 프로퍼티도 결국 객체라서, 객체 리터널로 생성할 수 있기 때문이다.

```javascript
function Gadget() {
	// 비공개 멤버
	var nmae = 'yun';
	// 공개함수
	this.getName = function () {
		return name
	};
}

Gadget.prototype = (function(){
	// 비공개 멤버
	var browser = 'Mobile Webkit';
	// 공개되 프로토타입
	return {
		getBrower : function(){
			return browser;
		}
	};
})();

var toy = new Gadget();
console.log(toy.getName); // 객체 인스턴스의 특권 메서드
console.log(toy.browser); // 프로토타입의 특권 메서드
```

### 비공개 함수를 공개 메서드로 노출 시키는 방법
* 추후 추가....


### 모둘패턴

* 모듈 패턴은 늘어나는 코드를 구조화하고 정리하는데 도움이 되기 때문에 널리 쓰인다.
* 다른 언어와 달리 자바스크립트에서 패키지를 위한 별도의 문법이 없다.
* 하지만 모듈 패턴을 사용한다면 개벌적인 코드를 느슨하게 결합시킬 수 있다.
* 따라서 각 기능들은 블랙박스처럼 다루면서 소프트웨어 개발 중에 요구사항에 따라 기능을 추가하거나 교체하거나 삭제하는 것도 자유롭게 할 수 있다.

#### 모듈 패턴은 다음 패턴들을 여러 개를 조합한 것이다.

* 네임스페이스 패턴
* 즉시 실행 함수
* 비공개 멤버와 특권 맴버
* 의존 관계 선언
