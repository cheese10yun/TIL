# 만들면서 배우는 헥사고날 아키텍처 설계와 구현

# 01 왜 헥사고날 아키텍처인가?

> 필리포 부루넬리스키가 자신의 아이디어가 올바르다는 것을증명하기 위해서 스스로 건물에 벽동을 쌓았던 피렌체 대성당의 예와 같이, 소프트웨어 아키텍트는 자신의 아키텍처가 훌륭하다는 것을 증명하기 위해 손을 더렵혀야 한다.

* 엔티티 * 값 객체 * 애플리케이션 헥사곤 * 프레임워크 헥사곤 * 드라이빙 오퍼레이선 * 드리븐 오퍼레이션 * 유스케이스 * 입력포트 * 출력포트


## Value Object

### Value Object 재사용

```kotlin
data class Address (
    val address: String,
    val addressDetail: String,
    val zipCode: String
)
```

```kotlin
class Member(
    val address: Address
)
```

```kotlin
// 
class Controller {
    
    
    @Post
    fun create(@RequestBody @Valid dto: MemberXXXRequest){
        
    }
}

data class MemberXXXRequest(
    // Value Object 를 그대로 사용해야 하느가?
    val address: Address
)

// 그렇게 되면 @file:NotEmpty 와 같은 의존성이 생기는데, 또 이게 외부 포트이기 때문에 분리해야하지 않나?
data class Address (
    @file:NotEmpty
    val address: String,
    @file:NotEmpty
    val addressDetail: String,
    @file:NotEmpty
    val zipCode: String
)
```


### Rich Object

```kotlin
@Document(collection = "members")
class Member(
    @Field(name = "member_id")
    val memberId: String,

    @Field(name = "name")
    val name: String,

    @Field(name = "email")
    val email: String,

    @Field(name = "address")
    val address: Address
){
    // val 이기 때문에 email 업데이트 코드가 없다.
}


// val 으로 만들고 업데이트만 하면 어떨지?..
class MemberCustomRepositoryImpl {

    override fun updateEmail() {
        val query = Query(Criteria.where("_id").`is`(1))
        val update = Update().set("email", "sample@asd.com")

        mongoTemplate.updateFirst(
            query,
            update,
            documentClass
        )
    }
}

// 순수하게 MemberRepositroy만 의존하는 관계
class MemberQueryService(
    private val memberRepository: MemberRepositroy
) {
    fun updateEmail() {
        // 기타 로직 작성
        memberRepository.update()
    }
}

// 행위를 위해서 모든 의존성을 가져온다.
class MemberEmailService(
    private val memberQueryService: MemberQueryService
) {
    fun updateEmail() {
        // 기타 로직 작성
        memberQueryService.update()
    }
}
```

#### Rich Obejct의 현실적인 한계

https://cheese10yun.github.io/code-design/#projection



# 02 도메인 헥사곤으로 비즈니스 규칙 감싸기

* 엔티티는 인프라스트럭처에 해당하는가 ?
* 빈약한 모델

# 03 

* given when then 으로 코드 작성하는 것이 흥미로웠음
* 대상(What)에 있지 않고 두 기법이 시스템 행위를 설명한다는 동일한 목적을 달성하는 방법(How)에 있다.
* 유스케이스를 인터페이스를 두어서 강제하는 것이 메리티가 있는지 의문
  * 부정적인 의견으로는 Service, ServiceImpl의 확장판으로 보임, 인터페이스를 구현하는 여러 구현체가 있고 기능에 따라 적절한 구현체 대체하기 위한 다형성,
  * 긍정적인 의견으로는 
    * 인터페이스만 바라보니 의존관계도 죽여 일명 DIP를 할 수 있음
    * 인터페이스를 통해서 조금더 행위 기반으로 책임을 위임할 수 있음 MemberService 이런거 극혐함 
* 멀티 모듈이라면 애매하지 않나

* 인터페이스로 묶는게 현실적으로 될까 ?
```java
public interface ChangePasswordService {
    public void change(MemberId id, PasswordDto.ChangeRequest dto);
}

public class ByAuthChangePasswordService implements ChangePasswordService {
    private MemberFindService memberFindService;

    @Override
    public void change(MemberId id, PasswordDto.ChangeRequest dto) {
        if (dto.getAuthCode().equals("인증 코드가 적합한지 로직 추가...")) {
            final Member member = memberFindService.findById(id);
            final String newPassword = dto.getNewPassword().getValue();
            member.changePassword(newPassword);
            // 필요로직...
        }
    }
}


// 비밀번호 기반 
public class ByPasswordChangePasswordService implements ChangePasswordService {
    private MemberFindService memberFindService;

    @Override
    public void change(MemberId id, PasswordDto.ChangeRequest dto) {
        if (dto.getPassword().equals("비밀번호가 일치하는지 판단 로직...")) {
            final Member member = memberFindService.findById(id);
            final String newPassword = dto.getNewPassword().getValue();
            member.changePassword(newPassword);
        }
    }
}

@Getter
@NoArgsConstructor(access = AccessLevel.PROTECTED)
public static class ChangeRequest {
  private String authCode;
  private Password password;
  private Password newPassword;
}
```

ChangeRequest 으로 통일될까?...


```
|-- MemberApplication.java
|-- application
|   |-- inputport
|   |   |-- AddMemberInputPort.java
|   |   |-- InquiryMemberInputPort.java
|   |   |-- SavePointInputPort.java
|   |   `-- UsePointInputPort.java
|   |-- outputport
|   |   `-- MemberOutPutPort.java
|   `-- usecase
|       |-- AddMemberUsecase.java
|       |-- InquiryMemberUsecase.java
|       |-- SavePointUsecase.java
|       `-- UsePointUsecase.java
|-- config
|   |-- KafkaConfig.java
|   `-- SwaggerConfig.java
|-- domain
|   `-- model
|       |-- Member.java
|       |-- event
|       |   |-- EventResult.java
|       |   |-- EventType.java
|       |   |-- Item.java
|       |   |-- ItemRented.java
|       |   |-- ItemReturned.java
|       |   |-- OverdueCleared.java
|       |   `-- PointUseCommand.java
|       `-- vo
|           |-- Authority.java
|           |-- Email.java
|           |-- IDName.java
|           |-- PassWord.java
|           |-- Point.java
|           `-- UserRole.java
`-- framework
    |-- jpaadapter
    |   |-- MemberJpaAdapter.java
    |   `-- MemberRepository.java
    |-- kafkaadapter
    |   |-- MemberEventConsumers.java
    |   `-- MemberEventProducer.java
    `-- web
        |-- MemberController.java
        `-- dto
            |-- MemberInfoDTO.java
            `-- MemberOutPutDTO.java
```

* 이렇게 나누는 것은 좋음
* usecase 케이스를 통해서 자연스럽게 행위 기반으로 객체를 할당할 수 있음
* framework
  * jpaadapter
  * web
  * 웹도 하나의 경역으로 그 경역을 한정하는 모습이 좋았음
