> [몽고 디비 완벽 가이드](http://www.yes24.com/Product/Goods/97980005)

# 1 몽고DB 소개

* 몽고DB는 도큐먼트 지향 데이터베이스다. 관계형 모델을 사용하지 않던 주된 이유는 분산 확장을 쉽게 하기 위함 이지만 다른 이점도 있다.
* 도큐먼트 지향 데이터베이스에서는 행 겨념 대신에 보다 유연한 모델인 도뮤컨트를 사용한다.
* 몽고DB에서는 도큐먼트의 키와 값을 미리 정의하지 않는다. 따라서 고정된 스키마가 없다.

## 확장 가능한 설계

몽고DB는 분산 확장을 염두에 두고 설계 됐다. 도큐먼트 지향 데이터 모델은 데이터를 여러 서버에 더 쉽게 분산하게 해준다. 도큐먼트를 자동으로 재분배하고 사용자 요청을 올바른 장비에 라우팅함으로써 클러스터 내 데이터 양과 부하를 조절할 수 있다.

몽고DB 클러스터의 토폴리지나 데이터베이스 연결의 다른 쪽 끝에 단일 노드가 아닌 클러스터가 있는지 애플리케이션에서 분명히 알 수 있다. 더 큰 부하를 지원하도록 기존에 배포된 애플리케이션의 토폴로지를 변경할 떄도 마찬가지로 애플리케이션 로직은 그대로 유지할 수 있다.

## 다양한 기능

### 인덱싱

몽고DB는 일반적인 보조 인덱스를 지원하며, 고유, 복합, 공간 정보, 전문 인덱싱 기능도 제공한다. 중첩된 도뮤컨트 및 배열과 같은 계층 구조의 보조 인ㄴ덱스도 지원하며, 개발자는 모델링 기능을 자신의 애플리케이션에 가장 적합한 방식으로 최대한 활용할 수 있다.

### 집계

몽고DB는 데이터 처리 파이프라인 개념을 기반으로 한 집계 프레임워크를 제공한다. 집계 파이프라인은 데이터베이스 최적화를 최대한 활용해, 서버 측에서 비교적 간단한 일련의 단예로 데이터를 처리함으로써 복잡한 분석 엔진을 구축하게 해준다.

### 특수한 컬렉션 유형

몽고DB는 로그와 같은 최신ㄴ 데이터를 유지하고자 세션이나 고정 크기 컬력센과 같이 특정 시간에 만려해야 하는 데이터에 대한 유효 시간 TTL 컬렉션을 지원한다. 또한 기준 필터와 일치하는 도큐먼트에 한정된 부분 인덱스를 지원함으로써 효율성을 높이고 필요한 젖아 공간을 줄인다.

### 파일 스토리지

몽고DB는 큰 파일에 파일 메타데이터를 편리하게 저장하는 프로토컬을 지원한다.

관계형 데이터베이스에 공통적으로 사용되는 일부 기능, 특히 복잡한 조인은 몽고DB에 존재하지 않는다. 몽고DB 3.2에 도입단 $lookup 집계 연산자를 사요함으로써 매우 제한된 방식으로 조인하도록 지원한다.

## 고성능

몽고DB에서는 동시성과 처리량을 극대화하기 위해 와이어드타이거 스토리지 엔진에 기회적 락을 사용했다. 따라서 캐시처럼 제한된 용량의 램으로 쿼리에 알맞은 인덱스를 자동으로 선택할 수 있다.몽고DB는 강력한 성능을 제공하면서 관계형 시스템의 많은 기능을 포함한다. 일부 기능의 경우 데이터베이스 서버는 처리와 로직을 클라이언트 측에 오프로드한다.(드라이버 또는 사용자의 애플리케이션 코드에의해 처리된다.)

# 2 몽고DB 기본

* 몽고DB 데이터의 기본 단위는 도큐먼트이며, 이는 관계형 데이터베이스의 행과 유사하다.
* 같은 맥락에서 컬렉션은 동적 스키마가 있는 테이블과 같다.
* 몽고DB의 단일 인스턴스는 자체적인 컬렉션을 갖는 여러 개의 독립적인 데이터베이스를 호스팅한다.
* 모든 도큐먼트 컬렉션 내에서 거유한 특수키인 "_id"를 가진다.
* 몽고DB는 몽고 쉘 이라는 도구로 몽고DB 인스턴스를 관리하고 몽고DB 쿼리 언어로 데이터를 조작하기 위한 내장 지원을 제공한다.

## 도큐먼트

* 도큐먼트의 키는 문자열이다. 몇 가지를 제외하면 어떤 UTF-8 문자든 쓸 수 있다.
* 몽고DB는 데이터형과 대소문자를 구분한다. 
  * { "count": 5 }, { "count": "5" } 서로 다르다.
* 몽고DB에서는 키가 중복될 수 없다.

## 컬렉션
컬렉션은 도큐먼트의 모음이다. 몽고DB의 도큐먼트가 관계형 데이터베이스의 행에 대응된다면 컬렉션은 테이블에 대응된다고 볼 수 있다.


### 동적 스키마
컬렉션은 동적 스키마를 가진다. 하나의 컬렉션 내 도큐먼트들이 모두 다른 구조를 가질 수 있다는 의미이다. 예를 들어 다음 도큐먼트들을 하나의 컬렉션에 저장할 수 있다.

```micronaut-mongodb-json
{
  "greeting": "Hello, world!",
  "views": 3
}
{
  "signoff": "Good night, and good luck"
}
```
**도큐먼트에 별도의 스키마가 필요 없는데 왜 하나 이상의 컬렉션이 필요한지는 몇가지 합당한 이유가 있다**

* 인덱스를 만들면 도큐먼트는 특정 구조를 가져야 한다. 고유 인덱스일 경우 특히 더 그렇다. 이러한 인덱스는 컬렉션별로 정의한다. 같은 유형의 도큐먼트를 하나의 컬렉션에 넣음으로써 컬렉션을 효율적으로 인덱싱할 수 있다.

### 서브컬렉션
서브컬렉션의 네임스페이스에 `.` 문자를 사용해 컬렉션을 체계화한다. blog.posts, blog.authors라는 컬렉션을 가질 수 있다. 이는 단지 체계화를 위함이며 blog 컬렉션이나 자식 컬렉션과는 아무런관계가 없다. 심지어 blog 컬렉션이 없어도된다. 서브컬렉션은 특별한 속성은 없지만 여러 몽고DB 툴에서 지원하므로 유용하다.

### 데이터베이스

몽고DB는 컬렉션에 도큐먼트를 그룹화할 뿐 아니라 데이터베이스에 컬렉션을 그룹지어 놓는다. 몽고DB의 단일 인스턴스는 여러 데이터베이스를 호스팅할 수 있으며, 각 데이터베이스를 완전히 독립적으로 취급할 수 있다.

## 몽고DB 셸 소개

몽고DB 명령행에서 몽고DB 인스턴스와 상호작용하는 자바스크립트 셸을 제공한다.

```
$ mongo
MongoDB server version: 4.4.18
Welcome to the MongoDB shell.
For interactive help, type "help".
For more comprehensive documentation, see
	https://docs.mongodb.com/
Questions? Try the MongoDB Developer Community Forums
	https://community.mongodb.com
	
	
> x = 200
200
> x / 5;
40
> Math.sin(Math.PI / 2)
1
> new Date("2023-01")
ISODate("2023-01-01T00:00:00Z")
```

### 몽고DB 클라이언트

셸은 독자적으로 사용이 가능하다. 셸은 시작할 때  서버의 test 데이터베이스에 연결하고, 데이터베이스 연결을 전역 변수에 db에 할당한다. 셸에서는 주로 이 변수를 통해 몽고DB에 접근한다.

### 셸 기본 작업

### 생성

```
db.movies
movie = {
  "title":"Start Wars",
  "director": "AJ",
  "year": 1977
}

db.movies.insertOne(movie)
db.movies.find().pretty()

[
  {
    "_id": {"$oid": "63d414430db2d501a49b3d9c"},
    "director": "AJ",
    "title": "Start Wars",
    "year": 1977
  }
]
```
insertOne 함수는 컬렉션에 도큐먼트를 추가한다. 우선 자바스크립트 객체인 movie라는 지역 변수를 생성한다. 그리고 insertOn 함수를 이용해 movies 컬렉션에 저장한다. `_id` 칼럼이 추가 되고 key/value 형태로 저장된다.

### 읽기

```spring-mongodb-json
db.movies.findOne()
[
  {
    "_id": {"$oid": "63d414430db2d501a49b3d9c"},
    "director": "AJ",
    "title": "Start Wars",
    "year": 1977
  }
]
```
find, findOne은 쿼리 도큐먼트 형태로 조건 전달도 가능하다. 따라서 쿼리에서 일치하는 도큐먼트로 결과를 제한한다.

### 갱신

updateOne으로 갱신을 진행하낟. 첫 번째 매개변수는 수정할 도큐먼트를 찾는 기준이고, 두 번째 매개변수는 해당 작업을 설명하는 도큐먼트이다. 영화에 ㄹ뷰 기능을 사용을 하기로 한다면 다음과 같이 진행된다.

```
db.movies.updateOne(
{title: "Start Wars"},
{$set: {comments: []}}
)

```

### 삭제
deleteOne, deleteMany는 도큐컨트를 데이터베이스에서 영구적으로 삭제한다.

```
db.movies.deleteOne({title:"Start Wars-2"})

[
  {
    "acknowledged": true,
    "deletedCount": 1
  }
]
```
deleteMany는 필터에 만족하는 모든 도큐먼트를 삭제하는 경우 사용한다.

## 데이터형

JSON 형식으로 다음과 같은 데이텨 형을 지원한다.

* null
* boolean
* number
* string
* object
* array

몽고DB는 JSON 성질을 유지하면서 추가적인 데이터 형을 지원한다.


* null: 값이 존재핮 ㅣ않은 필드를 표현 하는데 사용한다.
* boolean: 참거짓
* number: 셸은 64비트 부동 소수를 기본으로 사용한다. 
* string: 어떤 UTF-8 문자열이든 문자열형으로 표현 가능
* date: 1970년 1월 1일 부터 시간을 1/1000초 단위로 나타내는 64비트 정수로 날짜 표현, 표준 시간대는 저장하지 않는다.
* regular expression: 쿼리는 자바스크립트 정규 표현식 문법을 사용할 수 있다.
* array: set, list 형태로 표현할 수 있다.
* 내장 도큐먼트: `{"x" : {"foo": "bar"}}` 도큐먼트는 부모 도큐먼트의 값으로 내장된 도큐먼트 전체를 포함할 수 있다.
* 객체 ID: 도큐먼트용 12 바이트 ID
* 이진 데이터: 이진 데이터는 임의의 바이트 문자열이며 셸에서는 조작이 불가능하다. 이진 데이터는 데이터베이스에 UTF-8이 아닌 문자열을 저장하는 유일한 방법이다.
* 코드: `{"x": function() {....}}` 쿼리와 도큐먼트 임이의 자바스크립트 코드를 포함할 수 있다.


### 배열
배열은 정렬 연산(리스트, 스택, 큐)과 비정렬 연산(셋) 호환성있게 사용한 값이다.

```json
{"things": ["pie", 3.14]}
```
서로 다른 데이터형 값으로 포함할 수 있다. 중첩 배열도 가능하다. 배열에 쿼리하거나 배열의 내용을 이용해 인덱스를 만들 수 있다. 자주 쓰는 쿼리라면 "things" 키에 인덱스를 생성해 쿼리 속도를 향상시킬 수도 있다.

### 내장 도큐먼트
도큐먼트는 키 값에 대한 갑싱 될 수 있는데 이를 내장 도큐먼트라고 한다.

```json
{
  "name": "AJ",
  "address": {
    "street": "123 Park",
    "city": "A-Town",
    "state": "NY"
  }
}
```

address에 대한 key/value를 갖는 내장 도큐먼트이다.


### _id, ObjectId

몽고DB에 저장되는 모든 도큐컨트는 _id 키를 가진다. 하나의 컬렉션에서 모든 도큐먼트는 고유한 id를 가지며 이 값은 컬렉션 내 모든 도큐먼트가 고유하게 식별된다.

ObjectId는 여러 장비에 걸쳐 전역적으로 고유하게 생성하기 쉽게 설계됐다. 자동 증가하는 기본 키처럼 전통적인 것이 아닌 ObjectId를 사용하는 주요 이유는 몽고DB는 분산 특성이기 때문이다. ObjectId는 12바이트 스토리지를 사용하며 24자리 16진수 만자열 표현이 가능하다. 바이트당 2자리를 사용한다. ObjectId가 흔히 16진수 문자열로 표현되긴 하지만 실제로 문자열은 저장된 데이터의 두 배만큼 길다는 점을 알아두자.


# 3 도큐먼트 생성, 갱신, 삭제

## 도큐먼트 삽입

insertOne 메서드를 사용한다.

```
db.movies.insertOne({title: "타짜"})
```

그러면 도큐먼트에 _id 키가 추가되고 몽고DB에 저장된다.

### insertMany

여러 도큐먼트를 컬렉센여 삽입하려면 insertMany로 도큐먼트 배열을 데이터베이스에 전달한다. 코드가 삽입된 각 도큐먼트에 대해 데이터베이로 왕복하지 않고 도큐먼트를 대량으로 bulk insert 가능하다.

```
db.movies.insertMany(
  [
    {"title": "A1"},
    {"title": "A2"},
    {"title": "A3"},
    {"title": "A4"}
  ]
);
```

수천 개의 도큐먼트를 한 번에 전송하면 도큐먼트 삽입이 매우 빨라진다. 몽고DB는 현재 버전에서는 48메가바이트보다 큰 메시지를 허용하지 않으므로 한 번에 일괄 삽입할 수 있는 데이터의 크기에는 제한이 있다.


insertMany를 사용해 대량 삽입할 때 배열 중간에 있는 도큐먼트에서 특정 유형의 오류가 발생 하는 경우, 정렬 연산을 선택했는지 혹은 비정렬 연산을 선택해는지에 따라 발생하는 상황이 달라진다. insertMany에 옵션으로 도큐먼트가 제공된 순서대로 삽입되도록 옵션 도큐먼트에 "ordered" 값에 true를 지정한다(기본 값). false로 지정하면 몽고DB가 성능을 개선하려고 삽입을 재배열할 수 있다. ordered true인 경우 오류 발생 이후 부터는 insert 하지 않는 반면 ordered flase 경우 오류가 발생해도 모든 도큐먼트에 대해서 insert를 진행한다.

## 도큐먼트 삭제

deleteOne은 필터와 일치하는 첫 번째 도큐먼트를 삭제 한다. deleteMany는 필터와 일치하는 모든 도큐먼트를 삭제 한다. 컬렉션 전체를 삭제하려면 drop을 사용하는 것이 더 빠르다.


## 도큐먼트 갱신
updateOne, updateMany는 필터 도큐먼트를 첫 번째 매개변수로, 변경 사항을 설명하는 수정자 도큐먼트를 매개변수로 사용한다. replaceOne도 첫 번째 매배변수로 필터를 사용하지만 두 번째 매개변수는 필터와 일치하는 도큐먼트를 교체할 도큐먼트이다.


갱신은 원자적으로 이루어진다, 갱신 요청 두 개가 동시에 발생하면 서버에 먼저 도착한 요청이 적용된 후 다음 요청이 적용된다. 따라서 여려 개의 갱신 요청이 빠르게 발생하더라도 결국 마지막 요청이 최후의 승리자가 되므로 도큐먼트는 변질 없이 안전하게 처리된다. 기본 동작을 원치 않으면 도큐먼트 버저닝 패턴을 고려하자.

### 도큐먼트 치환

replaceOne은 도큐먼트를 새로운 것으로 완전히 치환한다. 

```
var j = db.users.findOne({"name": "J"});
j.relationships = {
"friedns": j.friedns,
"enmies": j.enmies
};

j.username = j.name;

delete j.friedns;
delete j.enmies;
delete j.name;

db.users.replaceOne({"name": "J"}, j)

db.users.find()
```

### 갱신 연사나

도큐먼트의 특정 부분만 갱신하는 경우에는 워나적 갱신 연사나를 사용한다. 갱신 연산자는 키를 변경, 추가, 제거하고, 배열과 내장 도큐먼트를 조작하는복잡한 갱신 연산을 지정하는 특수키다.

```
use analytics;

var a = {"pagevies": 12}

db.analytics.insertOne(a)

db.analytics.find()

db.analytics.updateOne(
  {"_id": ObjectId("63d42d790db2d501a49b3db2")},
  {"$inc": {"pagevies": 1}}
)

db.analytics.find()
```
$inc 제한자를 통해서 값을 증가 시킬 수 있다.

$set ㅔ한자는 필드가 존재하지 않는다면 새 필드가 생성된다. 이 기능은 스키마를 갱신하거나 사요아 정의를 추가할 떄 편리하다.

# 쿼리

## find 소개

find의 첫 매개변수에 따라 어떤 도큐먼트를 가져올지 결정된다. 빈 쿼리 경우 컬렉션 내 모든 것과 일치한다. 즉 전체 도큐먼트를 반환한다.

```
db.users.find({"name": "J"})
```
name이 J인 것을 조회, and 조건으로 더 추가 할 수 있다.


### 반환받을 키 지정

```
db.users.find({}, {"name": 1})
```
도큐먼트의 필드들을 선태적으로 조회할 수 있다. 네트워크, 클라이언트에서 디코딩하는 데 드는 시간과 메모리를 줄여 줄 수 있다. `_id`는 항상 반환된다.


## 쿼리 조건


### 쿼리 조건절
`<`, `<=`, `>`, `>=`에 해당하는 `$it`, `$lte`, `$gt`, `$gte`다

```
db.users.find({"age": {"$te": 18, "$lte": 30}})
```
18이상, 30 이하의 도큐먼트를 모두 찾는다.


### OR 쿼리

`$in`는 하나의 키를 다야한 값과 비교하는 쿼리로,`$or`는 더 일반적이며, 여러 키를 주어진 값과 비교하는 쿼리에 사용한다.

```
db.users.find(
  { 
    name: { "$in": ["J", "w"] }
  }
)
```
`$in`은 매우 유연해 여러 개의 값을 쓸 수 있을 뿐만 아니라 서로 다른 데이터형도 쓸 수 있다. `$nin`은 `$in` 반대로 배열 내 조건과 일치하지 않은 도큐먼트를 반환한다.


### `$not`
`$not`은 메타 조건 절이며 어떤 조건에도 적용할 수 있다.


## 형 특정 쿼리

### null
null은 일치하는 것을 찾는다. 여기서 중요한 것은 값이 null 것과, 값 자체가 존재하지 않는 것도 null로 간주하기 떄문에 쿼리하면 결과가 나온다. 그래서 값 자체가 null인 키만 찾고 있다면 `$exists`조건을 사용해서 null 존쟈 여뷰를 확인하면 된다.

```
db.users.find({"username": {"$eq": null, "$exists": true}});
```


### 내장 도큐먼트에 쿼리하기

```
db.users.find({"relationships": {"friedns": 32, "enmies": 2}})

db.users.find(
    {"relationships.enmies": 32, "relationships.enmies": 2}
)
```

서브도큐먼트 쿼리에 정확하게 일치 해야한다. 그러지 않으면 조회되지 않는다. 내장 도큐먼트키를 점 표기법으로 사용할 수 있다.  

# 5 인덱싱

* 인덱싱의 정의와 사용 이유
* 인덱싱할 필드를 선정하는 방법
* 인덱스 사용을 평가하고 적용하는 방법
* 인덱스 생성 및 제거에 대한 관리 정보

## 인덱싱 소개

인덱스를 사용하지 않는 쿼리를 컬렉션 스캔이라 하며, 서버가 쿼리 결과를 찾으려면 전체 내용을 살펴봐야 함을 의미한다.

```
db.users.find({"username": "user101"}).explain("executionStats")
```

executionStats 모드는 인덱스를 이용한 쿼리의 효과를 이해하는데 도움이 된다.


* mysql 인


### 궁금한거 정리
와이어드타이거??

* **도큐먼트에 별도의 스키마가 필요 없는데 왜 하나 이상의 컬렉션이 필요한지는 몇가지 합당한 이유가 있다**
* insertMany ordered 설명이 좀 이상함...?...
* 갱신 요청 두 개가 동시에 발생하면 서버에 먼저 도착한 요청이 적용된 후 다음 요청이 적용된다. 따라서 여려 개의 갱신 요청이 빠르게 발생하더라도 결국 마지막 요청이 최후의 승리자가 되므로 도큐먼트는 변질 없이 안전하게 처리된다. 기본 동작을 원치 않으면 도큐먼트 버저닝 패턴 설명....