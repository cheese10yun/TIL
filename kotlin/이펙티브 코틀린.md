> [이펙티브 코틀린](http://www.kyobobook.co.kr/product/detailViewKor.laf?mallGb=KOR&ejkGb=KOR&barcode=9788966263370)

# 1장 안전성

## 가변성을 제한하라

가변성이 발생하는 코드는 프로그래밈을 이해하고 디버그하기가 힘들어지며 이러한 사앹를 갖는 부분들의 관계를 이해햐아 하기 때문에 상태 변경이 많아지면 이를 추적하는것이 힘들어 진다.

### 코틀린에서 가변성 제한하기

* 읽기 전용 프로퍼티 val
* 가변 컬렉션과 읽기 전용 컬렉션 구분하기
* 데이터 클래스의 copy


#### 읽기 전용 프로퍼티 val
```kotlin
fun calculate(): Int {
    println("Calculating...")
    return 42
}
val fizz = calculate()
val buzz
    get() = calculate()

@Test
internal fun `test 1`() {

    println(fizz) // 42
    println(fizz) // 42
    println(buzz) // Calculating... 42
    println(buzz) // Calculating... 42
}
```

값을 추출할 때 마다 사용자 정의 게터가 호출되므로 이러한 결과가 나옵니다.

```kotlin
interface Element{
    val active: Boolean
}

class ActualElement : Element{
    override var active: Boolean = false // val를 오버라이딩 하여 var로 변경이 가능하다 그러므로 불변으로 하고 싶다면 final 까지 사용하는 것이 좋다
}
```


val는 읽기 전용 프로퍼티지만, 변경할 수 없음을 의미하는 것은 아닙니다. 또한 게터 또는 델리게이트로 정의할 수 있습니다. 만약 완전히 변경할 필요가 없다면, final 프로퍼티를 사용하는 것이 좋습니다. val는 정의 옆에 상태가 바로 적히므로 코드의 실행을 예측하는 것이 훨씬 간단 합니다. 또한 스마트 캐스트 등 추가적인 기능을 활용할 수 있습니다.

```kotlin
val name: String? = "Marton"
val surname: String = "Braun"

val fullName: String?
    get() = name?.let { "$it $surname" }

val fullName2: String? = name?.let { "$it $surname" }

@Test
internal fun `smart cast`() {

    if (fullName != null) {
        println(fullName.length) // 오류
    }

    if (fullName2 != null) {
        println(fullName2.length) // 12
    }
}
```

**fullName은 게터로 정의했기 때문에 스마트 캐스트할 수 없습니다. 게터를 활용하므로, 값을 사용하는 시점에 name에 따라서 다른 결과가 나올 수 있기 떄문입니다. fullName2 처럼 지역 변수가 아닌 프로퍼티가 final 이고 사용자 정의 게터를 갖지 않는 경우라면 스마트 캐스트할 수 있습니다.** 

#### 가변 컬렉션과 읽기 전용 컬렉션 구분하기

코틀린은 읽고 쓸 수 있는 프로퍼티와 읽기 전용 프로퍼티로 구분됩니다. 마찬가지로 컬렉션도 읽고 쓸 수 있는 컬렉션과 읽기 전 컬렉션으로 구분됩니다. 이는 컬렉션 계층이 설계된 방식 덕입니다.

Mutavble이 붙은 틴터페이스는 대응되는 읽기 전용 인터페이스를 상속 받아서, 변경을 위한 메서드를 추가한 것입니다. 이는 마치 일긱 전용 프로퍼티가 게터만 갖고, 일고 쓰기 전용 프로퍼타가 게터와 셋터를 모두 가지던 것과 비슷하게 동작합니다.

개발자가 다운캐스팅을 할 떄 문제가 됩니다. 읽기 전용으로 리턴하면 이를 읽기 전용으로만 사용해야 합니다. 이는 단순한 계약의 문제라고 할 수 있습니다.

```kotlin
@Test
internal fun `down casting 위반`() {
    val list = listOf(1, 2, 3)
    if (list is MutableList){
        list.add(1) // java.lang.UnsupportedOperationException 오류 발생
    }
}
```
변경은 가능하지만 Arrays.ArrayList는 이러한 연산을 구현하고 있지 않아 위와 같은 오류가 발생합니다.


#### 데이터 클래스의 Copy

String이나, Int 처럼 내부적인 사앹를 변경하지 않는 immutable 객체를 많이 사용하는데 이유가 있습니다.

1. 한 번 정의된 상태가 유지되므로, 코드를 이해하기 쉽습니다.
2. immutable 객체는 공유했을 때도 충돌이 따로 이루어지지 않으므로, 병렬 처리를 안전하게 할 수 있습니다.
3. immutable 객체에 대한 참조는 변경되지 않으므로, 쉽게 캐시할 수 있습니다.
4. immutable 객체는 방어적 복사본을 만들 필요가 없습니다. 또한 객체를 복사할 때 깊은 복사를 따로 하지 않아도 됩니다.
5. immutable 객체는 다른 객체를 만들 떄 활용하기 좋습니다. immutable 객체는 실행을 더 쉽게 예측할 수 있습니다.
6. immutable 객체는 set, map의 키로 사용할 수 있습니다. 이는 set, map은 내부적으로 해시 테이블을 사용하고, 해시 테이블은 처음 요소를 넣을 때 요소의 값을 기반으로 버킷을 결정하기 때문입니다.

```kotlin
@Test
fun `hash immutable`() {

    val names: SortedSet<FullName> = TreeSet()
    val person = FullName("AAA", "AAA")
    names.add(person)
    names.add(FullName("Jon", "Jon"))
    names.add(FullName("David", "David"))

    println(names) // [AAA AAA, Jon Jon, David]
    println(person in names) // true

    person.name = "ZZZ"
    println(names) // [AAA ZZZ, Jon Jon, David]
    println(person in names) // false
}
```

내부에 해당 객체가 있음에도 fale를 리턴합니다. 객체를 변경했기 때문에 찾을 수 없는 것입니다.


```kotlin
@Test
internal fun `none data`() {
    class User(
        val name: String,
        val surname: String,
    ) {
        fun withSurname(surname: String) = User(name, surname)
        override fun toString(): String {
            return "User(name='$name', surname='$surname')"
        }
    }
    var user = User("Maja", "Markiewicz")
    user = user.withSurname("Moskla")
    println(user) // User(name='Maja', surname='Moskla')
}
```

withSurname 메서드 처럼 자신을 수정한 새로운 객체를 만들어야 합니다. 다만 모든 프로퍼티 대상으로 이런 함수를 하나하나 만드는 것은 굉장히 귀찮은 일입니다. 이런 경우 data 한정자를 사용하면 됩니다. data 한정자의 copy 메서드는 모든 기본 생성자 프로퍼티가 같은 새로운 객체를 만들어 낼 수 있습니다.


```kotlin
@Test
internal fun `data copy`() {
    data class User(
        val name: String,
        val surname: String,
    ) {
        fun withSurname(surname: String) = User(name, surname)
        override fun toString(): String {
            return "User(name='$name', surname='$surname')"
        }
    }

    var user = User("Maja", "Markiewicz")
    user = user.copy(surname = "Moskla")
    println(user) // User(name='Maja', surname='Moskla')
}
```

변경을 할 수있다는 측면만 보면 mutable 객체가 더 좋아 보이지만, 이렇게 데이터 모델 클래스를 만들어 immutable 객체를 만드는 것이 더 많은 장점을 갖습니다.


```kotlin
@Test
internal fun `방어 로직`() {
    data class User(val name: String)

    class UserRepository {
        private val storedUsers: MutableMap<Int, String> = mutableMapOf()
        fun loadAll(): Map<Int, String> {
            return storedUsers
        }
    }

    val userRepository = UserRepository()
    val storedUsers = userRepository.loadAll()
    storedUsers[4] = "Kirill" // 컴파일 오류
}
```
객체를 읽기 전용 슈퍼타입으러 업캐스트하여 가변셩을 제한 할 수 있습니다.

### 변경 가능 지점 노출하지 말기

```kotlin
@Test
internal fun `변경 가능 지점 노출하지 말기`() {
    data class User(val name: String)

    class UserRepository {
        private val storedUsers: MutableMap<Int, String> = mutableMapOf()

        fun loadAll(): MutableMap<Int, String> {
            return storedUsers
        }
    }

    val userRepository = UserRepository()
    val storedUsers = userRepository.loadAll()
    storedUsers[4] = "Kirill"
}
```
loadAll을 사용해서 private 상태인 UserRepositroy를 수정할 수 있습니다. 



# 2장 가독성

# 3장 재사용성

# 4장 추상화 설계

# 5장 객체 생성

# 6장 클래스 설계

# 7장 효울상

# 8장 비용 줄이기