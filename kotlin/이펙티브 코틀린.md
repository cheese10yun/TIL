> [이펙티브 코틀린](http://www.kyobobook.co.kr/product/detailViewKor.laf?mallGb=KOR&ejkGb=KOR&barcode=9788966263370)

# 1장 안전성

## 가변성을 제한하라

가변성이 발생하는 코드는 프로그래밈을 이해하고 디버그하기가 힘들어지며 이러한 사앹를 갖는 부분들의 관계를 이해햐아 하기 때문에 상태 변경이 많아지면 이를 추적하는것이 힘들어 진다.

### 코틀린에서 가변성 제한하기

* 읽기 전용 프로퍼티 val
* 가변 컬렉션과 읽기 전용 컬렉션 구분하기
* 데이터 클래스의 copy


#### 읽기 전용 프로퍼티 val
```kotlin
fun calculate(): Int {
    println("Calculating...")
    return 42
}
val fizz = calculate()
val buzz
    get() = calculate()

@Test
internal fun `test 1`() {

    println(fizz) // 42
    println(fizz) // 42
    println(buzz) // Calculating... 42
    println(buzz) // Calculating... 42
}
```

값을 추출할 때 마다 사용자 정의 게터가 호출되므로 이러한 결과가 나옵니다.

```kotlin
interface Element{
    val active: Boolean
}

class ActualElement : Element{
    override var active: Boolean = false // val를 오버라이딩 하여 var로 변경이 가능하다 그러므로 불변으로 하고 싶다면 final 까지 사용하는 것이 좋다
}
```


val는 읽기 전용 프로퍼티지만, 변경할 수 없음을 의미하는 것은 아닙니다. 또한 게터 또는 델리게이트로 정의할 수 있습니다. 만약 완전히 변경할 필요가 없다면, final 프로퍼티를 사용하는 것이 좋습니다. val는 정의 옆에 상태가 바로 적히므로 코드의 실행을 예측하는 것이 훨씬 간단 합니다. 또한 스마트 캐스트 등 추가적인 기능을 활용할 수 있습니다.

```kotlin
val name: String? = "Marton"
val surname: String = "Braun"

val fullName: String?
    get() = name?.let { "$it $surname" }

val fullName2: String? = name?.let { "$it $surname" }

@Test
internal fun `smart cast`() {

    if (fullName != null) {
        println(fullName.length) // 오류
    }

    if (fullName2 != null) {
        println(fullName2.length) // 12
    }
}
```

**fullName은 게터로 정의했기 때문에 스마트 캐스트할 수 없습니다. 게터를 활용하므로, 값을 사용하는 시점에 name에 따라서 다른 결과가 나올 수 있기 때문입니다. fullName2 처럼 지역 변수가 아닌 프로퍼티가 final 이고 사용자 정의 게터를 갖지 않는 경우라면 스마트 캐스트할 수 있습니다.** 

#### 가변 컬렉션과 읽기 전용 컬렉션 구분하기

코틀린은 읽고 쓸 수 있는 프로퍼티와 읽기 전용 프로퍼티로 구분됩니다. 마찬가지로 컬렉션도 읽고 쓸 수 있는 컬렉션과 읽기 전 컬렉션으로 구분됩니다. 이는 컬렉션 계층이 설계된 방식 덕입니다.

Mutavble이 붙은 틴터페이스는 대응되는 읽기 전용 인터페이스를 상속 받아서, 변경을 위한 메서드를 추가한 것입니다. 이는 마치 일긱 전용 프로퍼티가 게터만 갖고, 일고 쓰기 전용 프로퍼타가 게터와 셋터를 모두 가지던 것과 비슷하게 동작합니다.

개발자가 다운캐스팅을 할 때 문제가 됩니다. 읽기 전용으로 리턴하면 이를 읽기 전용으로만 사용해야 합니다. 이는 단순한 계약의 문제라고 할 수 있습니다.

```kotlin
@Test
internal fun `down casting 위반`() {
    val list = listOf(1, 2, 3)
    if (list is MutableList){
        list.add(1) // java.lang.UnsupportedOperationException 오류 발생
    }
}
```
변경은 가능하지만 Arrays.ArrayList는 이러한 연산을 구현하고 있지 않아 위와 같은 오류가 발생합니다.


#### 데이터 클래스의 Copy

String이나, Int 처럼 내부적인 사앹를 변경하지 않는 immutable 객체를 많이 사용하는데 이유가 있습니다.

1. 한 번 정의된 상태가 유지되므로, 코드를 이해하기 쉽습니다.
2. immutable 객체는 공유했을 때도 충돌이 따로 이루어지지 않으므로, 병렬 처리를 안전하게 할 수 있습니다.
3. immutable 객체에 대한 참조는 변경되지 않으므로, 쉽게 캐시할 수 있습니다.
4. immutable 객체는 방어적 복사본을 만들 필요가 없습니다. 또한 객체를 복사할 때 깊은 복사를 따로 하지 않아도 됩니다.
5. immutable 객체는 다른 객체를 만들 때 활용하기 좋습니다. immutable 객체는 실행을 더 쉽게 예측할 수 있습니다.
6. immutable 객체는 set, map의 키로 사용할 수 있습니다. 이는 set, map은 내부적으로 해시 테이블을 사용하고, 해시 테이블은 처음 요소를 넣을 때 요소의 값을 기반으로 버킷을 결정하기 때문입니다.

```kotlin
@Test
fun `hash immutable`() {

    val names: SortedSet<FullName> = TreeSet()
    val person = FullName("AAA", "AAA")
    names.add(person)
    names.add(FullName("Jon", "Jon"))
    names.add(FullName("David", "David"))

    println(names) // [AAA AAA, Jon Jon, David]
    println(person in names) // true

    person.name = "ZZZ"
    println(names) // [AAA ZZZ, Jon Jon, David]
    println(person in names) // false
}
```

내부에 해당 객체가 있음에도 fale를 리턴합니다. 객체를 변경했기 때문에 찾을 수 없는 것입니다.


```kotlin
@Test
internal fun `none data`() {
    class User(
        val name: String,
        val surname: String,
    ) {
        fun withSurname(surname: String) = User(name, surname)
        override fun toString(): String {
            return "User(name='$name', surname='$surname')"
        }
    }
    var user = User("Maja", "Markiewicz")
    user = user.withSurname("Moskla")
    println(user) // User(name='Maja', surname='Moskla')
}
```

withSurname 메서드 처럼 자신을 수정한 새로운 객체를 만들어야 합니다. 다만 모든 프로퍼티 대상으로 이런 함수를 하나하나 만드는 것은 굉장히 귀찮은 일입니다. 이런 경우 data 한정자를 사용하면 됩니다. data 한정자의 copy 메서드는 모든 기본 생성자 프로퍼티가 같은 새로운 객체를 만들어 낼 수 있습니다.


```kotlin
@Test
internal fun `data copy`() {
    data class User(
        val name: String,
        val surname: String,
    ) {
        fun withSurname(surname: String) = User(name, surname)
        override fun toString(): String {
            return "User(name='$name', surname='$surname')"
        }
    }

    var user = User("Maja", "Markiewicz")
    user = user.copy(surname = "Moskla")
    println(user) // User(name='Maja', surname='Moskla')
}
```

변경을 할 수있다는 측면만 보면 mutable 객체가 더 좋아 보이지만, 이렇게 데이터 모델 클래스를 만들어 immutable 객체를 만드는 것이 더 많은 장점을 갖습니다.


```kotlin
@Test
internal fun `방어 로직`() {
    data class User(val name: String)

    class UserRepository {
        private val storedUsers: MutableMap<Int, String> = mutableMapOf()
        fun loadAll(): Map<Int, String> {
            return storedUsers
        }
    }

    val userRepository = UserRepository()
    val storedUsers = userRepository.loadAll()
    storedUsers[4] = "Kirill" // 컴파일 오류
}
```
객체를 읽기 전용 슈퍼타입으러 업캐스트하여 가변셩을 제한 할 수 있습니다.

### 변경 가능 지점 노출하지 말기

```kotlin
@Test
internal fun `변경 가능 지점 노출하지 말기`() {
    data class User(val name: String)

    class UserRepository {
        private val storedUsers: MutableMap<Int, String> = mutableMapOf()

        fun loadAll(): MutableMap<Int, String> {
            return storedUsers
        }
    }

    val userRepository = UserRepository()
    val storedUsers = userRepository.loadAll()
    storedUsers[4] = "Kirill"
}
```
loadAll을 사용해서 private 상태인 UserRepositroy를 수정할 수 있습니다. 


## 아이템 2 변수의 스코프를 최소화하라

* 프로퍼티보다는 지역 변수를 사용하는 것이 좋습니다.
* 최대한 좁은 스코프를 갖게 변수를 사용 합니다.

```kotlin
@Test
internal fun `변수의 스코프를 최소화하라`(users: List<User>) {
    // 나쁜 예
    var user: User
    for (index in users.indices) {
        user = users[index]
        println("User at $index is $user")

    }

    // 조금 더 좋은 예
    for (index in users.indices) {
        val user = users[index]
        println("User at $index is $user")
    }

    // 제일 좋은 예
    for ((index, user) in users.withIndex()) {
        println("User at $index is $user")
    }
}

@Test
internal fun `구조 분해 선언`() {
    // 나쁜 예
    val user: User
    if (true) {
        user = getValue()
    } else {
        user = User()
    }

    // 좋은 예
    val user: User = if (true) {
        getValue()
    } else {
        User()
    }
}
```


## 아이템 3 최대한 플랫폼 타입을 사용하지 말

플랫폼 타입은 String! 처럼 타입 이름 뒤에 ! 기호를 붙여서 표시합니다.

```java
public class UserRepo {
    public User getUser() {
        // ...
    }
}
```

```kotlin
// kotlin
val repo = UserRepo()
val user1 = repo.user           // user1 타입은 User!
val user2: User = repo.user     // user2 타입은 User
val user3: User? = repo.user    // user3 타입은 User?
```

null일 가능성이 있으므로, 여전히 위험 함니다. 그래서 플랫폼 타입을 사용할 때는 항상 주의 해야합니다. 설계자가 명시적으로 어노테이션으로 표시하거나, 주석으로 달아두지 않으면, 언제든지 동작이 변경될 가능성이 있습니다.

```java
import org.jetbrtains.annotations.NotNull;

public class UserRepo {
    public @NotNull User getUser() {
        // ...
    }
}
```

`@NotNull`를 사용하여 null를 리턴하지 않는다는 것을 표시합니다.


## 아이템 4 inferred 타입으로 리턴하지 말라

**inferred 타입은 정확하게 오른쪽에 있는 피연산자에 맞게 설정된다는 것을 기억해야 합니다. 절대로 슈퍼 클래스 또는 인터페이스로 설정되지 않습니다.**

```kotlin
@Test
internal fun `아이템 4 inferred 타입으로 리턴하지 말라`() {
    open class Animal
    class Zebra : Animal()
    
    var animal = Zebra()
    animal = Animal() // 오류: type mismatch

    var animal: Animal = Zebra() // 슈퍼 클래래스, 또는 인터페이스로 설정하지 않고 정확하게 피연산자에 맞게 설정
    animal = Animal() // 오류 없음
}
```

## 아이템 5 예외를 활용해 코드에 제한을 걸아라

* require 블록: 아규먼트를 제한할 수 있습니다.
* check 블록: 상태와 관련된 동작을 제한할 수 있습니다.
* assert 블록: 어떤 것이 true인지 확인할 수 있습니다. assert 블록은 테스트 모드에서만 동작합니다.
* return 또는 throw와 함께 활용하는 Elvis 연산자

## 아이템 6 사용자 정의 오류보다는 표준 오류를 사용하라

표준 라이브러리에 있는 예외를 활용하고 적절한 오류가 없으면 사용자 정의 오류를 정의해서 사용하는 것아 바람직합니다.


## 아이템 7 결과 부족이 발생할 경우 null과 Failure를 사용하라

* 서버로부터 데이터를 읽어 들이려고 했는데, 인터넷 연결 문제로 읽어 들이지 못하는 경우
* 조건에 맞는 첫번쨰 요소를 찾으려 했는데, 조건에 맞는 요소가 없는 경우
* 텍스트를 파싱해서 객체를 만들려고 했는데, 텍스트의 형식이 맞지 않는 경우

이러한 상황을 처리하는 메커니즘은 크게 다음과 같이 두가지가 있습니다.

* null 또는 실패를 나타내는 sealed 클래스(일반적으로 Failure 라는 이름을 붙입니다.)를 리턴한다.
* 예외를 throw 한다.

우선 예외는 정보를 전달하는 아법으로 사용해서는 안됩니다. 예외는 잘못된 특별한 상황을 나타내야 하며 처리되어야 합니다. 예외는 예외적인 상황이 발생했을 때 사용하는 것이 좋습니다. 이유는 다음과 같습니다.

* 많은 개발자는 예외가 전파되는 과정을 제대로 추적하지 못합니다.
* 코틀린의 모든 예외는 unchecked 예외입니다. 따라서 사용자가 예외를 처리하지 않을 수도 있으며, 이와 관련된 내용은 문서에도 제대로 드러나지 않습니다.
* 예외는 예외적인 상황을 처리하기 위해서 만들어졌으므로 명시적인 테스트만큼 빠르게 동작하지 않습니다.
* try-catch 블록 내부에 코드를 배치하면, 컴파일러가 할 수이쓴ㄴ 최적화가 제한됩니다.

반면, 첫 번쨰로 설명했단 null과 Failure는 예상되는 오류를 표현할 때 굉장히 좋습니다. 명시적으로 효율적이며, 간단한 방법으로 처리할 수 있습니다. **따라서 충분히 예측할 수 있는 범위 오류는 null가, Failure를 사용하고 예측 하기 어려운 예외적인 오유는 예외를 throw 해서 처리하는 것이 좋습니다.**

```kotlin
inline fun <reified T> String.readObjectOrNull(): T? {
        if (...) {
            return null
        }

        return result
    }

    inline fun <reified T> String.readObject(): Result<T> {
        if (...){
            return Failure(JsonParsingException()) 
        }

        return Success(result)
    }

    sealed class Result<out T>
    class Success<out T>(val result: T) : Result<T>()
    class Failure(val throwable: Throwable) : Result<Nothing>()

    class JsonParsingException : Exception()


// readObjectOrNull 처리 방법
val age = userText.readObjectOrNull<Person>()?.age ?: -1

// readObject 처리 방법
val person = userText.readObjectOrNull<Person>()
val age = when (person) {
    is Success -> person.age
    is Failure -> -1
}
```

## 아이템 8 적절하게 null을 처리하라


### lateinit 프로퍼티와 notNull 델리게이트

프로퍼티가 반드시 초기화 해야하는 경우 사용합니다. lateinit 한정자는 프로피티가 이후에 설정될 것임을 명시한 한정자입니다. 

```kotlin
data class UserControllerTest {
    private lateinit var dao : UserDao
    private lateinit var controller: UserController
    
    
    @BeforeEach
    fun init(){
        dao = mockk()
        controller = UserController(dao)
    }

    @Test
    internal fun test() {
        controller.doSometing()   
    }
}
```
lateinit는 nullable과 비교해서 다음과 같은 차이가 있습니다.

* !! 연산자로 언팩 하지 않아도 됩니다.
* 이후에 어떤 의미를 나타내기 위해서 null을 사용하고 싶을 때, nullable로 만들 수 있습니다.
* 프로퍼티가 초기화 된 이후에는 초기화 되지 않은 상태로 돌아갈 수 없습니다.

lateinit를 사용할 수 없는 경우도 있습니다. JVM에서 Int, Long, Double, Boolean과 같은 기본 타입과 연결된 타입으로 프로퍼티를 초기화해야 하는 경우입니다. 이런 경우 lateinit 보다는 약간 느리지만 Delegates.notNull을 사용합니다.


## 아이템 9 use를 사용하여 리소르를 닫아라

더 이상 필요하지 않을 때, close 메서드를 사용해서 명시적으로 닫아야하는 리소스가 있습니다.

* InputStream, OutputSteam
* java.sql.Connection
* java.io.Reader
* java.new.Socket

이러한 모든 리소스는 최종적으로 리소스에 대한 레퍼런스가 없어질 때, 가비지 컬렉터가 처리합니다. 하지만 광장히 느리며 그동안 리소스를 유지하는 비용이 많이 들어갑니다. 따라서 더 이상 사용하지 않는다명 명시적으로 close를 호출해 사용하는 것이 좋습니다. 전통적으로 이러한 리소스는 다음과 같이 try-finally 블록을 사용해서 처리했습니다.

하지만 이런 방식은 광장히 복잡하고 좋지 않습니다. 리소스를 닫을 때 예외가 발생할 수도 있는데, 이러한 예외를 따로 처리하지 않기 때문에 try finally 블록 냐부애소 오류가 발생한다면 둘 중 하나만 전파됩니다. 둘다 전파가 될수 있도록 하면 좋지만 이를 직접 구현하려면 코드가 굉장히 길고 복잡해집니다. 그래서 이러한 표준 라이브러리에는 use라는 이름의 함수로 포함되어 있습니다. 이러한 코드는 모두 Closeable 객체에서 사용할 수 있습니다.


```kotlin
fun countCharactersInFile(path: String): Int {
    BufferedReader(FileReader(path)).use { reader ->
        return reader.lineSequence().sumOf { it.length }
    }
}
```

파일을 리소스로 사용하는 경우가 적고, 파일을 한 줄씩 일겅 들이는 경우에는 useLines 함수도 제공합니다.

```kotlin
fun countCharactersInFile(path: String): Int {
    BufferedReader(FileReader(path)).use { reader ->
        return reader.lineSequence().sumOf { it.length }
    }
}
```
이렇게 처리하면 메모리에 파일의 내용을 한 줄 씩만 유지하므로, 대용량 파일도 적절하게 처리할 수 있습니다. 다만 파일의 줄을 한 번만 사용할 수 있다는 단점도 있습니다. 파일의 특정 줄을 두 번 이상 반복 처리할 필요가 없다면 좋은 대안이 됩니다.

## 아이템 10 단위 테스트를 만들어라
..

# 2장 가독성

## 이름 있는 아규먼트를 사용하라

### 이름 있는 아규먼트는 언제 사용해야 할까?
* 이름을 기반으로 값이 무엇을 나타내는지 알 수 있습니다.
* 파라미터 입력 순서와 상관 없으므로 안전합니다.


### 디폴트 아규먼트의 경우

프로피터가 디폴트 아규먼트를 가질 경우, 항상 이름을 붙여 사용하는 것이 좋습니다. 일반적으로 함수 이름은 필수 파라미터들과 관련돠어 있기 때문애 이플토 값을 갖는 옵션 파라미터의 설명이 명확하지 않습니다. 따라서 이런 경우에는 이름을 붙여서 사용하는 것이 좋습니다.


### 같은 타임의 파라미터가 많은 경우
파라미터가 모든 다른 타입이라면, 위치를 잘못 입력하면 오류가 발생할 것이기 때문에 쉽게 문제를 발견할 수 있는데 파라미터 타입이 같다면 잘못 입력하는 경우 문제를 찾기 어려울 수 있습니다. 이런 경우 이름 있는 아규먼트를 사용하는 것이 좋습니다.

### 함수 타입 파라미터

일반적으로 함수 타입 파라미터는 마지막 위치에 배치하는 것이 좋습니다.

# 3장 재사용성

# 4장 추상화 설계

# 5장 객체 생성

# 6장 클래스 설계

# 7장 효울상

# 8장 비용 줄이기